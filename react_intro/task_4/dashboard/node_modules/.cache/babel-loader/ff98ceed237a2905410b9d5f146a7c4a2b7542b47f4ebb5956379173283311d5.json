{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/* eslint-disable class-methods-use-this */\n/* eslint-disable max-classes-per-file */\nconst react_1 = __importDefault(require(\"react\"));\nconst react_dom_1 = __importDefault(require(\"react-dom\"));\nconst client_1 = require(\"react-dom/client\");\nconst shallow_1 = __importDefault(require(\"react-test-renderer/shallow\"));\nconst test_utils_1 = __importDefault(require(\"react-dom/test-utils\"));\nconst has_1 = __importDefault(require(\"has\"));\nconst react_is_1 = require(\"react-is\");\nconst enzyme_1 = require(\"enzyme\");\nconst Utils_1 = require(\"enzyme/build/Utils\");\nconst enzyme_shallow_equal_1 = __importDefault(require(\"enzyme-shallow-equal\"));\nconst enzyme_adapter_utils_1 = require(\"./enzyme-adapter-utils\");\nconst findCurrentFiberUsingSlowPath_1 = __importDefault(require(\"./findCurrentFiberUsingSlowPath\"));\nconst detectFiberTags_1 = __importDefault(require(\"./detectFiberTags\"));\nconst FIBER_TAGS = (0, detectFiberTags_1.default)();\nfunction nodeAndSiblingsArray(nodeWithSibling) {\n  const array = [];\n  let node = nodeWithSibling;\n  while (node != null) {\n    array.push(node);\n    node = node.sibling;\n  }\n  return array;\n}\nfunction flatten(arr) {\n  const result = [];\n  const stack = [{\n    i: 0,\n    array: arr\n  }];\n  while (stack.length) {\n    const n = stack.pop();\n    while (n.i < n.array.length) {\n      const el = n.array[n.i];\n      n.i += 1;\n      if (Array.isArray(el)) {\n        stack.push(n);\n        stack.push({\n          i: 0,\n          array: el\n        });\n        break;\n      }\n      result.push(el);\n    }\n  }\n  return result;\n}\nfunction nodeTypeFromType(type) {\n  if (type === react_is_1.Portal) {\n    return 'portal';\n  }\n  return (0, enzyme_adapter_utils_1.nodeTypeFromType)(type);\n}\nfunction isMemo(type) {\n  return (0, enzyme_adapter_utils_1.compareNodeTypeOf)(type, react_is_1.Memo);\n}\nfunction isLazy(type) {\n  return (0, enzyme_adapter_utils_1.compareNodeTypeOf)(type, react_is_1.Lazy);\n}\nfunction unmemoType(type) {\n  return isMemo(type) ? type.type : type;\n}\nfunction checkIsSuspenseAndCloneElement(el, _ref) {\n  let {\n    suspenseFallback\n  } = _ref;\n  if (!(0, react_is_1.isSuspense)(el)) {\n    return el;\n  }\n  let {\n    children\n  } = el.props;\n  if (suspenseFallback) {\n    const {\n      fallback\n    } = el.props;\n    children = replaceLazyWithFallback(children, fallback);\n  }\n  function FakeSuspenseWrapper(props) {\n    return react_1.default.createElement(el.type, {\n      ...el.props,\n      ...props\n    }, children);\n  }\n  return react_1.default.createElement(FakeSuspenseWrapper, null, children);\n}\nfunction elementToTree(el) {\n  if (!(0, react_is_1.isPortal)(el)) {\n    return (0, enzyme_adapter_utils_1.elementToTree)(el, elementToTree);\n  }\n  const {\n    children,\n    containerInfo\n  } = el;\n  const props = {\n    children,\n    containerInfo\n  };\n  return {\n    nodeType: 'portal',\n    type: react_is_1.Portal,\n    props,\n    key: (0, enzyme_adapter_utils_1.ensureKeyOrUndefined)(el.key),\n    ref: el.ref || null,\n    instance: null,\n    rendered: elementToTree(el.children)\n  };\n}\nfunction toTree(vnode) {\n  if (vnode == null) {\n    return null;\n  }\n  // TODO(lmr): I'm not really sure I understand whether or not this is what\n  // i should be doing, or if this is a hack for something i'm doing wrong\n  // somewhere else. Should talk to sebastian about this perhaps\n  const node = (0, findCurrentFiberUsingSlowPath_1.default)(vnode);\n  switch (node.tag) {\n    case FIBER_TAGS.HostRoot:\n      return childrenToTree(node.child);\n    case FIBER_TAGS.HostPortal:\n      {\n        const {\n          stateNode: {\n            containerInfo\n          },\n          memoizedProps: children\n        } = node;\n        const props = {\n          containerInfo,\n          children\n        };\n        return {\n          nodeType: 'portal',\n          type: react_is_1.Portal,\n          props,\n          key: (0, enzyme_adapter_utils_1.ensureKeyOrUndefined)(node.key),\n          ref: node.ref,\n          instance: null,\n          rendered: childrenToTree(node.child)\n        };\n      }\n    case FIBER_TAGS.ClassComponent:\n      return {\n        nodeType: 'class',\n        type: node.type,\n        props: {\n          ...node.memoizedProps\n        },\n        key: (0, enzyme_adapter_utils_1.ensureKeyOrUndefined)(node.key),\n        ref: node.ref,\n        instance: node.stateNode,\n        rendered: childrenToTree(node.child)\n      };\n    case FIBER_TAGS.FunctionalComponent:\n      return {\n        nodeType: 'function',\n        type: node.type,\n        props: {\n          ...node.memoizedProps\n        },\n        key: (0, enzyme_adapter_utils_1.ensureKeyOrUndefined)(node.key),\n        ref: node.ref,\n        instance: null,\n        rendered: childrenToTree(node.child)\n      };\n    case FIBER_TAGS.MemoClass:\n      return {\n        nodeType: 'class',\n        type: node.elementType.type,\n        props: {\n          ...node.memoizedProps\n        },\n        key: (0, enzyme_adapter_utils_1.ensureKeyOrUndefined)(node.key),\n        ref: node.ref,\n        instance: node.stateNode,\n        rendered: childrenToTree(node.child.child)\n      };\n    case FIBER_TAGS.MemoSFC:\n      {\n        let renderedNodes = flatten(nodeAndSiblingsArray(node.child).map(toTree));\n        if (renderedNodes.length === 0) {\n          renderedNodes = [node.memoizedProps.children];\n        }\n        return {\n          nodeType: 'function',\n          type: node.elementType,\n          props: {\n            ...node.memoizedProps\n          },\n          key: (0, enzyme_adapter_utils_1.ensureKeyOrUndefined)(node.key),\n          ref: node.ref,\n          instance: null,\n          rendered: renderedNodes\n        };\n      }\n    case FIBER_TAGS.HostComponent:\n      {\n        let renderedNodes = flatten(nodeAndSiblingsArray(node.child).map(toTree));\n        if (renderedNodes.length === 0) {\n          renderedNodes = [node.memoizedProps.children];\n        }\n        return {\n          nodeType: 'host',\n          type: node.type,\n          props: {\n            ...node.memoizedProps\n          },\n          key: (0, enzyme_adapter_utils_1.ensureKeyOrUndefined)(node.key),\n          ref: node.ref,\n          instance: node.stateNode,\n          rendered: renderedNodes\n        };\n      }\n    case FIBER_TAGS.HostText:\n      return node.memoizedProps;\n    case FIBER_TAGS.Fragment:\n    case FIBER_TAGS.Mode:\n    case FIBER_TAGS.ContextProvider:\n    case FIBER_TAGS.ContextConsumer:\n      return childrenToTree(node.child);\n    case FIBER_TAGS.Profiler:\n    case FIBER_TAGS.ForwardRef:\n      {\n        return {\n          nodeType: 'function',\n          type: node.type,\n          props: {\n            ...node.pendingProps\n          },\n          key: (0, enzyme_adapter_utils_1.ensureKeyOrUndefined)(node.key),\n          ref: node.ref,\n          instance: null,\n          rendered: childrenToTree(node.child)\n        };\n      }\n    case FIBER_TAGS.Suspense:\n      {\n        return {\n          nodeType: 'function',\n          type: react_is_1.Suspense,\n          props: {\n            ...node.memoizedProps\n          },\n          key: (0, enzyme_adapter_utils_1.ensureKeyOrUndefined)(node.key),\n          ref: node.ref,\n          instance: null,\n          rendered: childrenToTree(node.child)\n        };\n      }\n    case FIBER_TAGS.Lazy:\n      return childrenToTree(node.child);\n    case FIBER_TAGS.OffscreenComponent:\n      return toTree(node.child);\n    default:\n      throw new Error(`Enzyme Internal Error: unknown node with tag ${node.tag}`);\n  }\n}\nfunction childrenToTree(node) {\n  if (!node) {\n    return null;\n  }\n  const children = nodeAndSiblingsArray(node);\n  if (children.length === 0) {\n    return null;\n  }\n  if (children.length === 1) {\n    return toTree(children[0]);\n  }\n  return flatten(children.map(toTree));\n}\nfunction nodeToHostNode(_node) {\n  // NOTE(lmr): node could be a function component\n  // which wont have an instance prop, but we can get the\n  // host node associated with its return value at that point.\n  // Although this breaks down if the return value is an array,\n  // as is possible with React 16.\n  let node = _node;\n  while (node && !Array.isArray(node) && node.instance === null) {\n    node = node.rendered;\n  }\n  // if the SFC returned null effectively, there is no host node.\n  if (!node) {\n    return null;\n  }\n  const mapper = item => {\n    if (item && item.instance) return react_dom_1.default.findDOMNode(item.instance);\n    return null;\n  };\n  if (Array.isArray(node)) {\n    return node.map(mapper);\n  }\n  if (Array.isArray(node.rendered) && node.nodeType === 'class') {\n    return node.rendered.map(mapper);\n  }\n  return mapper(node);\n}\nfunction replaceLazyWithFallback(node, fallback) {\n  if (!node) {\n    return null;\n  }\n  if (Array.isArray(node)) {\n    return node.map(el => replaceLazyWithFallback(el, fallback));\n  }\n  if (isLazy(node.type)) {\n    return fallback;\n  }\n  return {\n    ...node,\n    props: {\n      ...node.props,\n      children: replaceLazyWithFallback(node.props.children, fallback)\n    }\n  };\n}\nfunction getEmptyStateValue() {\n  // this handles a bug in React 16.0 - 16.2\n  // see https://github.com/facebook/react/commit/39be83565c65f9c522150e52375167568a2a1459\n  // also see https://github.com/facebook/react/pull/11965\n  class EmptyState extends react_1.default.Component {\n    render() {\n      return null;\n    }\n  }\n  const testRenderer = new shallow_1.default();\n  testRenderer.render(react_1.default.createElement(EmptyState));\n  return testRenderer._instance.state;\n}\n// @ts-ignore\nconst wrapAct = react_1.default.unstable_act || test_utils_1.default.act;\nfunction getProviderDefaultValue(Provider) {\n  // React stores references to the Provider's defaultValue differently across versions.\n  if ('_defaultValue' in Provider._context) {\n    return Provider._context._defaultValue;\n  }\n  if ('_currentValue' in Provider._context) {\n    return Provider._context._currentValue;\n  }\n  throw new Error('Enzyme Internal Error: can’t figure out how to get Provider’s default value');\n}\nfunction makeFakeElement(type) {\n  return {\n    $$typeof: react_is_1.Element,\n    type\n  };\n}\nfunction isStateful(Component) {\n  return Component.prototype && (Component.prototype.isReactComponent || Array.isArray(Component.__reactAutoBindPairs)) // fallback for createClass components\n  ;\n}\nclass ReactEighteenAdapter extends enzyme_1.EnzymeAdapter {\n  constructor() {\n    super();\n    // @ts-expect-error\n    const {\n      lifecycles\n    } = this.options;\n    // @ts-expect-error\n    this.options = {\n      // @ts-expect-error\n      ...this.options,\n      enableComponentDidUpdateOnSetState: true,\n      legacyContextMode: 'parent',\n      lifecycles: {\n        ...lifecycles,\n        componentDidUpdate: {\n          onSetState: true\n        },\n        getDerivedStateFromProps: {\n          hasShouldComponentUpdateBug: false\n        },\n        getSnapshotBeforeUpdate: true,\n        setState: {\n          skipsComponentDidUpdateOnNullish: true\n        },\n        getChildContext: {\n          calledByRenderer: false\n        },\n        getDerivedStateFromError: true\n      }\n    };\n  }\n  createMountRenderer(options) {\n    globalThis.IS_REACT_ACT_ENVIRONMENT = true;\n    (0, enzyme_adapter_utils_1.assertDomAvailable)('mount');\n    if ((0, has_1.default)(options, 'suspenseFallback')) {\n      throw new TypeError('`suspenseFallback` is not supported by the `mount` renderer');\n    }\n    const {\n      attachTo,\n      hydrateIn,\n      wrappingComponentProps\n    } = options;\n    const domNode = hydrateIn || attachTo || global.document.createElement('div');\n    let instance = null;\n    let rootNode = null;\n    const adapter = this;\n    let unmountFlag = false;\n    return {\n      render(el, context, callback) {\n        return wrapAct(() => {\n          if (instance === null) {\n            const {\n              type,\n              props,\n              ref\n            } = el;\n            const wrapperProps = {\n              Component: type,\n              props,\n              wrappingComponentProps,\n              context,\n              onRenderCb: that => {\n                instance = that;\n              },\n              ...(ref && {\n                refProp: ref\n              })\n            };\n            const ReactWrapperComponent = (0, enzyme_adapter_utils_1.createMountWrapper)(el, {\n              ...options,\n              adapter\n            });\n            const wrappedEl = react_1.default.createElement(ReactWrapperComponent, wrapperProps);\n            if (hydrateIn) {\n              rootNode = (0, client_1.hydrateRoot)(domNode);\n            } else {\n              rootNode = (0, client_1.createRoot)(domNode);\n            }\n            rootNode.render(wrappedEl);\n            // console.log('rendering to', { rootNode });\n            if (typeof callback === 'function') {\n              callback();\n            }\n          } else {\n            instance.setChildProps(el.props, context, callback);\n          }\n        });\n      },\n      unmount() {\n        // ReactWrapper calls getNode after unmounting, which will try to get nodes\n        // un an unmounted tree. So we flag it instead.\n        unmountFlag = true;\n      },\n      getNode() {\n        let node;\n        // Many node types will not have an instance (like functional components), should we consider throwing a user facing error here?\n        if (!instance) {\n          node = null;\n        } else {\n          node = (0, enzyme_adapter_utils_1.getNodeFromRootFinder)(adapter.isCustomComponent, toTree(instance._reactInternals), options);\n        }\n        if (unmountFlag) {\n          wrapAct(() => {\n            rootNode === null || rootNode === void 0 ? void 0 : rootNode.unmount();\n            instance = null;\n          });\n        }\n        return node;\n      },\n      wrap: wrapAct,\n      simulateError(nodeHierarchy, rootNode, error) {\n        const isErrorBoundary = _ref2 => {\n          let {\n            instance: elInstance,\n            type\n          } = _ref2;\n          if (type && type.getDerivedStateFromError) {\n            return true;\n          }\n          return elInstance && elInstance.componentDidCatch;\n        };\n        const {\n          instance: catchingInstance,\n          type: catchingType\n        } = nodeHierarchy.find(isErrorBoundary) || {};\n        wrapAct(() => {\n          (0, enzyme_adapter_utils_1.simulateError)(error, catchingInstance, rootNode, nodeHierarchy, nodeTypeFromType, adapter.displayNameOfNode, catchingType);\n        });\n      },\n      async simulateEvent(node, event, mock) {\n        const hostNode = adapter.nodeToHostNode(node);\n        const mappedEvent = (0, enzyme_adapter_utils_1.mapNativeEventNames)(event);\n        const eventFn = test_utils_1.default.Simulate[mappedEvent];\n        // console.log('Simulate on', hostNode, mock);\n        if (!eventFn) {\n          throw new TypeError(`ReactWrapper::simulate() event '${event}' does not exist`);\n        }\n        await wrapAct(() => {\n          eventFn(hostNode, mock);\n        });\n      },\n      batchedUpdates: react_dom_1.default.unstable_batchedUpdates,\n      getWrappingComponentRenderer() {\n        return {\n          ...this,\n          ...(0, enzyme_adapter_utils_1.getWrappingComponentMountRenderer)({\n            toTree: inst => toTree(inst._reactInternals),\n            getMountWrapperInstance: () => instance\n          })\n        };\n      },\n      wrapInvoke: wrapAct\n    };\n  }\n  createShallowRenderer() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const adapter = this;\n    const renderer = new shallow_1.default();\n    // @ts-expect-error\n    const {\n      suspenseFallback\n    } = options;\n    if (typeof suspenseFallback !== 'undefined' && typeof suspenseFallback !== 'boolean') {\n      throw TypeError('`options.suspenseFallback` should be boolean or undefined');\n    }\n    let isDOM = false;\n    let cachedNode = null;\n    let lastComponent = null;\n    let wrappedComponent = null;\n    const sentinel = {};\n    // wrap memo components with a PureComponent, or a class component with sCU\n    const wrapPureComponent = (Component, compare) => {\n      if (lastComponent !== Component) {\n        if (isStateful(Component)) {\n          wrappedComponent = class extends Component {};\n          if (compare) {\n            // @ts-expect-error\n            wrappedComponent.prototype.shouldComponentUpdate = nextProps => !compare(this.props, nextProps);\n          } else {\n            wrappedComponent.prototype.isPureReactComponent = true;\n          }\n        } else {\n          let memoized = sentinel;\n          let prevProps;\n          wrappedComponent = function wrappedComponentFn(props) {\n            const shouldUpdate = memoized === sentinel || (compare ? !compare(prevProps, props) : !(0, enzyme_shallow_equal_1.default)(prevProps, props));\n            if (shouldUpdate) {\n              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                args[_key - 1] = arguments[_key];\n              }\n              memoized = Component({\n                ...Component.defaultProps,\n                ...props\n              }, ...args);\n              prevProps = props;\n            }\n            return memoized;\n          };\n        }\n        Object.assign(wrappedComponent, Component, {\n          displayName: adapter.displayNameOfNode({\n            type: Component\n          })\n        });\n        lastComponent = Component;\n      }\n      return wrappedComponent;\n    };\n    // Wrap functional components on versions prior to 16.5,\n    // to avoid inadvertently pass a `this` instance to it.\n    const wrapFunctionalComponent = Component => {\n      if ((0, has_1.default)(Component, 'defaultProps')) {\n        if (lastComponent !== Component) {\n          wrappedComponent = Object.assign(function (props) {\n            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n              args[_key2 - 1] = arguments[_key2];\n            }\n            return Component({\n              ...Component.defaultProps,\n              ...props\n            }, ...args);\n          }, Component, {\n            displayName: adapter.displayNameOfNode({\n              type: Component\n            })\n          });\n          lastComponent = Component;\n        }\n        return wrappedComponent;\n      }\n      return Component;\n    };\n    const renderElement = function (elConfig) {\n      for (var _len3 = arguments.length, rest = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        rest[_key3 - 1] = arguments[_key3];\n      }\n      const renderedEl = renderer.render(elConfig, ...rest);\n      const typeIsExisted = !!(renderedEl && renderedEl.type);\n      if (typeIsExisted) {\n        const clonedEl = checkIsSuspenseAndCloneElement(renderedEl, {\n          suspenseFallback\n        });\n        const elementIsChanged = clonedEl.type !== renderedEl.type;\n        if (elementIsChanged) {\n          return renderer.render({\n            ...elConfig,\n            type: clonedEl.type\n          }, ...rest);\n        }\n      }\n      return renderedEl;\n    };\n    return {\n      render(el, unmaskedContext) {\n        let {\n          providerValues = new Map()\n        } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        cachedNode = el;\n        if (typeof el.type === 'string') {\n          isDOM = true;\n        } else if ((0, react_is_1.isContextProvider)(el)) {\n          providerValues.set(el.type, el.props.value);\n          const MockProvider = Object.assign(props => props.children, el.type);\n          return (0, enzyme_adapter_utils_1.withSetStateAllowed)(() => renderElement({\n            ...el,\n            type: MockProvider\n          }));\n        } else if ((0, react_is_1.isContextConsumer)(el)) {\n          const Provider = adapter.getProviderFromConsumer(el.type);\n          const value = providerValues.has(Provider) ? providerValues.get(Provider) : getProviderDefaultValue(Provider);\n          const MockConsumer = Object.assign(props => props.children(value), el.type);\n          return (0, enzyme_adapter_utils_1.withSetStateAllowed)(() => renderElement({\n            ...el,\n            type: MockConsumer\n          }));\n        } else {\n          isDOM = false;\n          let renderedEl = el;\n          if (isLazy(renderedEl)) {\n            throw TypeError('`React.lazy` is not supported by shallow rendering.');\n          }\n          renderedEl = checkIsSuspenseAndCloneElement(renderedEl, {\n            suspenseFallback\n          });\n          const {\n            type: Component\n          } = renderedEl;\n          const context = (0, enzyme_adapter_utils_1.getMaskedContext)(Component.contextTypes, unmaskedContext);\n          if (isMemo(el.type)) {\n            const {\n              type: InnerComp,\n              compare\n            } = el.type;\n            return (0, enzyme_adapter_utils_1.withSetStateAllowed)(() => renderElement({\n              ...el,\n              type: wrapPureComponent(InnerComp, compare)\n            }, context));\n          }\n          const isComponentStateful = isStateful(Component);\n          if (!isComponentStateful && typeof Component === 'function') {\n            return (0, enzyme_adapter_utils_1.withSetStateAllowed)(() => renderElement({\n              ...renderedEl,\n              type: wrapFunctionalComponent(Component)\n            }, context));\n          }\n          if (isComponentStateful) {\n            if (renderer._instance && el.props === renderer._instance.props && !(0, enzyme_shallow_equal_1.default)(context, renderer._instance.context)) {\n              const {\n                restore\n              } = (0, enzyme_adapter_utils_1.spyMethod)(renderer, '_updateClassComponent', originalMethod => function _updateClassComponent() {\n                const {\n                  props\n                } = renderer._instance;\n                const clonedProps = {\n                  ...props\n                };\n                renderer._instance.props = clonedProps;\n                for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n                  args[_key4] = arguments[_key4];\n                }\n                const result = originalMethod.apply(renderer, args);\n                renderer._instance.props = props;\n                restore();\n                return result;\n              });\n            }\n            // fix react bug; see implementation of `getEmptyStateValue`\n            const emptyStateValue = getEmptyStateValue();\n            if (emptyStateValue) {\n              Object.defineProperty(Component.prototype, 'state', {\n                configurable: true,\n                enumerable: true,\n                get() {\n                  return null;\n                },\n                set(value) {\n                  if (value !== emptyStateValue) {\n                    Object.defineProperty(this, 'state', {\n                      configurable: true,\n                      enumerable: true,\n                      value,\n                      writable: true\n                    });\n                  }\n                }\n              });\n            }\n          }\n          return (0, enzyme_adapter_utils_1.withSetStateAllowed)(() => renderElement(renderedEl, context));\n        }\n      },\n      unmount() {\n        renderer.unmount();\n      },\n      getNode() {\n        if (isDOM) {\n          return elementToTree(cachedNode);\n        }\n        const output = renderer.getRenderOutput();\n        return {\n          nodeType: nodeTypeFromType(cachedNode.type),\n          type: cachedNode.type,\n          props: cachedNode.props,\n          key: (0, enzyme_adapter_utils_1.ensureKeyOrUndefined)(cachedNode.key),\n          ref: cachedNode.ref,\n          instance: renderer._instance,\n          rendered: Array.isArray(output) ? flatten(output).map(el => elementToTree(el)) : elementToTree(output)\n        };\n      },\n      simulateError(nodeHierarchy, rootNode, error) {\n        (0, enzyme_adapter_utils_1.simulateError)(error, renderer._instance, cachedNode, nodeHierarchy.concat(cachedNode), nodeTypeFromType, adapter.displayNameOfNode, cachedNode.type);\n      },\n      simulateEvent(node, event) {\n        for (var _len5 = arguments.length, args = new Array(_len5 > 2 ? _len5 - 2 : 0), _key5 = 2; _key5 < _len5; _key5++) {\n          args[_key5 - 2] = arguments[_key5];\n        }\n        const handler = node.props[(0, enzyme_adapter_utils_1.propFromEvent)(event)];\n        if (handler) {\n          (0, enzyme_adapter_utils_1.withSetStateAllowed)(() => {\n            // TODO(lmr): create/use synthetic events\n            // TODO(lmr): emulate React's event propagation\n            // ReactDOM.unstable_batchedUpdates(() => {\n            handler(...args);\n            // });\n          });\n        }\n      },\n      batchedUpdates(fn) {\n        return fn();\n        // return ReactDOM.unstable_batchedUpdates(fn);\n      },\n      // checkPropTypes(typeSpecs, values, location, hierarchy) {\n      //   return checkPropTypes(typeSpecs, values, location, displayNameOfNode(cachedNode), () =>\n      //     getComponentStack(hierarchy.concat([cachedNode])),);\n      // },\n      checkPropTypes(typeSpecs, values, location, hierarchy) {\n        return true;\n      }\n    };\n  }\n  createStringRenderer(options) {\n    if ((0, has_1.default)(options, 'suspenseFallback')) {\n      throw new TypeError('`suspenseFallback` should not be specified in options of string renderer');\n    }\n    // JSDOM >= 17 has begun removing Node API's from global.\n    // To avoid having to change environment for specific tests, it makes sense to globally 'polyfil' these after the fact.\n    if (!globalThis.TextEncoder) {\n      throw new Error(`Using Jest and/or JSDOM? TextEncoder needs to be available in the \\`global\\` scope to use Enzyme.render(<Component />).\nAdd the following to your test suite setup file (\"setupfile\" option in Jest), to polyfill it:\n\\`\\`\\`\n  import util from 'util';\n  Object.defineProperty(global, 'TextEncoder', {\n    value: util.TextEncoder,\n  });\n\\`\\`\\``);\n    }\n    const ReactDOMServer = require('react-dom/server');\n    return {\n      render(el, context) {\n        if (options.context && (el.type.contextTypes || options.childContextTypes)) {\n          const childContextTypes = {\n            ...(el.type.contextTypes || {}),\n            ...options.childContextTypes\n          };\n          const ContextWrapper = (0, enzyme_adapter_utils_1.createRenderWrapper)(el, context, childContextTypes);\n          return ReactDOMServer.renderToStaticMarkup(react_1.default.createElement(ContextWrapper));\n        }\n        return ReactDOMServer.renderToStaticMarkup(el);\n      }\n    };\n  }\n  // Provided a bag of options, return an `EnzymeRenderer`. Some options can be implementation\n  // specific, like `attach` etc. for React, but not part of this interface explicitly.\n  createRenderer(options) {\n    switch (options.mode) {\n      // @ts-expect-error\n      case enzyme_1.EnzymeAdapter.MODES.MOUNT:\n        // enzyme.mount()\n        return this.createMountRenderer(options);\n      // @ts-expect-error\n      case enzyme_1.EnzymeAdapter.MODES.SHALLOW:\n        // enzyme.shallow()\n        return this.createShallowRenderer(options);\n      // @ts-expect-error\n      case enzyme_1.EnzymeAdapter.MODES.STRING:\n        // enzyme.render()\n        return this.createStringRenderer(options);\n      default:\n        throw new Error(`Enzyme Internal Error: Unrecognized mode: ${options.mode}`);\n    }\n  }\n  wrap(element) {\n    return (0, enzyme_adapter_utils_1.wrap)(element);\n  }\n  // converts an RSTNode to the corresponding JSX Pragma Element. This will be needed\n  // in order to implement the `Wrapper.mount()` and `Wrapper.shallow()` methods, but should\n  // be pretty straightforward for people to implement.\n  nodeToElement(node) {\n    if (!node || typeof node !== 'object') return null;\n    const {\n      type\n    } = node;\n    return react_1.default.createElement(unmemoType(type), (0, enzyme_adapter_utils_1.propsWithKeysAndRef)(node));\n  }\n  matchesElementType(node, matchingType) {\n    if (!node) {\n      return node;\n    }\n    const {\n      type\n    } = node;\n    return unmemoType(type) === unmemoType(matchingType);\n  }\n  elementToNode(element) {\n    return elementToTree(element);\n  }\n  nodeToHostNode(node) {\n    let supportsArray = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const nodes = nodeToHostNode(node);\n    if (Array.isArray(nodes) && !supportsArray) {\n      // get the first non-null node\n      return nodes.filter(Boolean)[0];\n    }\n    return nodes;\n  }\n  displayNameOfNode(node) {\n    if (!node) return null;\n    const {\n      type,\n      $$typeof\n    } = node;\n    const adapter = this;\n    const nodeType = type || $$typeof;\n    // newer node types may be undefined, so only test if the nodeType exists\n    if (nodeType) {\n      switch (nodeType) {\n        case react_is_1.ConcurrentMode || NaN:\n          return 'ConcurrentMode';\n        case react_is_1.Fragment || NaN:\n          return 'Fragment';\n        case react_is_1.StrictMode || NaN:\n          return 'StrictMode';\n        case react_is_1.Profiler || NaN:\n          return 'Profiler';\n        case react_is_1.Portal || NaN:\n          return 'Portal';\n        case react_is_1.Suspense || NaN:\n          return 'Suspense';\n        default:\n      }\n    }\n    const $$typeofType = type && type.$$typeof;\n    switch ($$typeofType) {\n      case react_is_1.ContextConsumer || NaN:\n        return 'ContextConsumer';\n      case react_is_1.ContextProvider || NaN:\n        return 'ContextProvider';\n      case react_is_1.Memo || NaN:\n        {\n          const nodeName = (0, enzyme_adapter_utils_1.displayNameOfNode)(node);\n          return typeof nodeName === 'string' ? nodeName : `Memo(${adapter.displayNameOfNode(type)})`;\n        }\n      case react_is_1.ForwardRef || NaN:\n        {\n          if (type.displayName) {\n            return type.displayName;\n          }\n          const name = adapter.displayNameOfNode({\n            type: type.render\n          });\n          return name ? `ForwardRef(${name})` : 'ForwardRef';\n        }\n      case react_is_1.Lazy || NaN:\n        {\n          return 'lazy';\n        }\n      default:\n        return (0, enzyme_adapter_utils_1.displayNameOfNode)(node);\n    }\n  }\n  isValidElement(element) {\n    return (0, react_is_1.isElement)(element);\n  }\n  isValidElementType(object) {\n    return !!object && (0, react_is_1.isValidElementType)(object);\n  }\n  isFragment(fragment) {\n    return (0, Utils_1.typeOfNode)(fragment) === react_is_1.Fragment;\n  }\n  isCustomComponent(type) {\n    const fakeElement = makeFakeElement(type);\n    return !!type && (typeof type === 'function' || (0, react_is_1.isForwardRef)(fakeElement) || (0, react_is_1.isContextProvider)(fakeElement) || (0, react_is_1.isContextConsumer)(fakeElement) || (0, react_is_1.isSuspense)(fakeElement));\n  }\n  isContextConsumer(type) {\n    return !!type && (0, react_is_1.isContextConsumer)(makeFakeElement(type));\n  }\n  isCustomComponentElement(inst) {\n    if (!inst || !this.isValidElement(inst)) {\n      return false;\n    }\n    return this.isCustomComponent(inst.type);\n  }\n  getProviderFromConsumer(Consumer) {\n    // React stores references to the Provider on a Consumer differently across versions.\n    if (Consumer) {\n      let Provider;\n      if (Consumer._context) {\n        // check this first, to avoid a deprecation warning\n        ({\n          Provider\n        } = Consumer._context);\n      } else if (Consumer.Provider) {\n        ({\n          Provider\n        } = Consumer);\n      }\n      if (Provider) {\n        return Provider;\n      }\n    }\n    throw new Error('Enzyme Internal Error: can’t figure out how to get Provider from Consumer');\n  }\n  createElement() {\n    // @ts-expect-error\n    return react_1.default.createElement(...arguments);\n  }\n  // @ts-expect-error\n  wrapWithWrappingComponent(node, options) {\n    return {\n      RootFinder: enzyme_adapter_utils_1.RootFinder,\n      node: (0, enzyme_adapter_utils_1.wrapWithWrappingComponent)(react_1.default.createElement, node, options)\n    };\n  }\n}\nexports.default = ReactEighteenAdapter;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","react_1","require","react_dom_1","client_1","shallow_1","test_utils_1","has_1","react_is_1","enzyme_1","Utils_1","enzyme_shallow_equal_1","enzyme_adapter_utils_1","findCurrentFiberUsingSlowPath_1","detectFiberTags_1","FIBER_TAGS","default","nodeAndSiblingsArray","nodeWithSibling","array","node","push","sibling","flatten","arr","result","stack","i","length","n","pop","el","Array","isArray","nodeTypeFromType","type","Portal","isMemo","compareNodeTypeOf","Memo","isLazy","Lazy","unmemoType","checkIsSuspenseAndCloneElement","_ref","suspenseFallback","isSuspense","children","props","fallback","replaceLazyWithFallback","FakeSuspenseWrapper","createElement","elementToTree","isPortal","containerInfo","nodeType","key","ensureKeyOrUndefined","ref","instance","rendered","toTree","vnode","tag","HostRoot","childrenToTree","child","HostPortal","stateNode","memoizedProps","ClassComponent","FunctionalComponent","MemoClass","elementType","MemoSFC","renderedNodes","map","HostComponent","HostText","Fragment","Mode","ContextProvider","ContextConsumer","Profiler","ForwardRef","pendingProps","Suspense","OffscreenComponent","Error","nodeToHostNode","_node","mapper","item","findDOMNode","getEmptyStateValue","EmptyState","Component","render","testRenderer","_instance","state","wrapAct","unstable_act","act","getProviderDefaultValue","Provider","_context","_defaultValue","_currentValue","makeFakeElement","$$typeof","Element","isStateful","prototype","isReactComponent","__reactAutoBindPairs","ReactEighteenAdapter","EnzymeAdapter","constructor","lifecycles","options","enableComponentDidUpdateOnSetState","legacyContextMode","componentDidUpdate","onSetState","getDerivedStateFromProps","hasShouldComponentUpdateBug","getSnapshotBeforeUpdate","setState","skipsComponentDidUpdateOnNullish","getChildContext","calledByRenderer","getDerivedStateFromError","createMountRenderer","globalThis","IS_REACT_ACT_ENVIRONMENT","assertDomAvailable","TypeError","attachTo","hydrateIn","wrappingComponentProps","domNode","global","document","rootNode","adapter","unmountFlag","context","callback","wrapperProps","onRenderCb","that","refProp","ReactWrapperComponent","createMountWrapper","wrappedEl","hydrateRoot","createRoot","setChildProps","unmount","getNode","getNodeFromRootFinder","isCustomComponent","_reactInternals","wrap","simulateError","nodeHierarchy","error","isErrorBoundary","_ref2","elInstance","componentDidCatch","catchingInstance","catchingType","find","displayNameOfNode","simulateEvent","event","mock","hostNode","mappedEvent","mapNativeEventNames","eventFn","Simulate","batchedUpdates","unstable_batchedUpdates","getWrappingComponentRenderer","getWrappingComponentMountRenderer","inst","getMountWrapperInstance","wrapInvoke","createShallowRenderer","arguments","undefined","renderer","isDOM","cachedNode","lastComponent","wrappedComponent","sentinel","wrapPureComponent","compare","shouldComponentUpdate","nextProps","isPureReactComponent","memoized","prevProps","wrappedComponentFn","shouldUpdate","_len","args","_key","defaultProps","assign","displayName","wrapFunctionalComponent","_len2","_key2","renderElement","elConfig","_len3","rest","_key3","renderedEl","typeIsExisted","clonedEl","elementIsChanged","unmaskedContext","providerValues","Map","isContextProvider","set","MockProvider","withSetStateAllowed","isContextConsumer","getProviderFromConsumer","has","get","MockConsumer","getMaskedContext","contextTypes","InnerComp","isComponentStateful","restore","spyMethod","originalMethod","_updateClassComponent","clonedProps","_len4","_key4","apply","emptyStateValue","configurable","enumerable","writable","output","getRenderOutput","concat","_len5","_key5","handler","propFromEvent","fn","checkPropTypes","typeSpecs","values","location","hierarchy","createStringRenderer","TextEncoder","ReactDOMServer","childContextTypes","ContextWrapper","createRenderWrapper","renderToStaticMarkup","createRenderer","mode","MODES","MOUNT","SHALLOW","STRING","element","nodeToElement","propsWithKeysAndRef","matchesElementType","matchingType","elementToNode","supportsArray","nodes","filter","Boolean","ConcurrentMode","NaN","StrictMode","$$typeofType","nodeName","name","isValidElement","isElement","isValidElementType","object","isFragment","fragment","typeOfNode","fakeElement","isForwardRef","isCustomComponentElement","Consumer","wrapWithWrappingComponent","RootFinder"],"sources":["/Users/nyiriekpeat/Desktop/Projects/alu-web_react/react_intro/task_4/dashboard/node_modules/@cfaester/enzyme-adapter-react-18/dist/ReactEighteenAdapter.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/* eslint-disable class-methods-use-this */\n/* eslint-disable max-classes-per-file */\nconst react_1 = __importDefault(require(\"react\"));\nconst react_dom_1 = __importDefault(require(\"react-dom\"));\nconst client_1 = require(\"react-dom/client\");\nconst shallow_1 = __importDefault(require(\"react-test-renderer/shallow\"));\nconst test_utils_1 = __importDefault(require(\"react-dom/test-utils\"));\nconst has_1 = __importDefault(require(\"has\"));\nconst react_is_1 = require(\"react-is\");\nconst enzyme_1 = require(\"enzyme\");\nconst Utils_1 = require(\"enzyme/build/Utils\");\nconst enzyme_shallow_equal_1 = __importDefault(require(\"enzyme-shallow-equal\"));\nconst enzyme_adapter_utils_1 = require(\"./enzyme-adapter-utils\");\nconst findCurrentFiberUsingSlowPath_1 = __importDefault(require(\"./findCurrentFiberUsingSlowPath\"));\nconst detectFiberTags_1 = __importDefault(require(\"./detectFiberTags\"));\nconst FIBER_TAGS = (0, detectFiberTags_1.default)();\nfunction nodeAndSiblingsArray(nodeWithSibling) {\n    const array = [];\n    let node = nodeWithSibling;\n    while (node != null) {\n        array.push(node);\n        node = node.sibling;\n    }\n    return array;\n}\nfunction flatten(arr) {\n    const result = [];\n    const stack = [{ i: 0, array: arr }];\n    while (stack.length) {\n        const n = stack.pop();\n        while (n.i < n.array.length) {\n            const el = n.array[n.i];\n            n.i += 1;\n            if (Array.isArray(el)) {\n                stack.push(n);\n                stack.push({ i: 0, array: el });\n                break;\n            }\n            result.push(el);\n        }\n    }\n    return result;\n}\nfunction nodeTypeFromType(type) {\n    if (type === react_is_1.Portal) {\n        return 'portal';\n    }\n    return (0, enzyme_adapter_utils_1.nodeTypeFromType)(type);\n}\nfunction isMemo(type) {\n    return (0, enzyme_adapter_utils_1.compareNodeTypeOf)(type, react_is_1.Memo);\n}\nfunction isLazy(type) {\n    return (0, enzyme_adapter_utils_1.compareNodeTypeOf)(type, react_is_1.Lazy);\n}\nfunction unmemoType(type) {\n    return isMemo(type) ? type.type : type;\n}\nfunction checkIsSuspenseAndCloneElement(el, { suspenseFallback }) {\n    if (!(0, react_is_1.isSuspense)(el)) {\n        return el;\n    }\n    let { children } = el.props;\n    if (suspenseFallback) {\n        const { fallback } = el.props;\n        children = replaceLazyWithFallback(children, fallback);\n    }\n    function FakeSuspenseWrapper(props) {\n        return react_1.default.createElement(el.type, { ...el.props, ...props }, children);\n    }\n    return react_1.default.createElement(FakeSuspenseWrapper, null, children);\n}\nfunction elementToTree(el) {\n    if (!(0, react_is_1.isPortal)(el)) {\n        return (0, enzyme_adapter_utils_1.elementToTree)(el, elementToTree);\n    }\n    const { children, containerInfo } = el;\n    const props = { children, containerInfo };\n    return {\n        nodeType: 'portal',\n        type: react_is_1.Portal,\n        props,\n        key: (0, enzyme_adapter_utils_1.ensureKeyOrUndefined)(el.key),\n        ref: el.ref || null,\n        instance: null,\n        rendered: elementToTree(el.children),\n    };\n}\nfunction toTree(vnode) {\n    if (vnode == null) {\n        return null;\n    }\n    // TODO(lmr): I'm not really sure I understand whether or not this is what\n    // i should be doing, or if this is a hack for something i'm doing wrong\n    // somewhere else. Should talk to sebastian about this perhaps\n    const node = (0, findCurrentFiberUsingSlowPath_1.default)(vnode);\n    switch (node.tag) {\n        case FIBER_TAGS.HostRoot:\n            return childrenToTree(node.child);\n        case FIBER_TAGS.HostPortal: {\n            const { stateNode: { containerInfo }, memoizedProps: children, } = node;\n            const props = { containerInfo, children };\n            return {\n                nodeType: 'portal',\n                type: react_is_1.Portal,\n                props,\n                key: (0, enzyme_adapter_utils_1.ensureKeyOrUndefined)(node.key),\n                ref: node.ref,\n                instance: null,\n                rendered: childrenToTree(node.child),\n            };\n        }\n        case FIBER_TAGS.ClassComponent:\n            return {\n                nodeType: 'class',\n                type: node.type,\n                props: { ...node.memoizedProps },\n                key: (0, enzyme_adapter_utils_1.ensureKeyOrUndefined)(node.key),\n                ref: node.ref,\n                instance: node.stateNode,\n                rendered: childrenToTree(node.child),\n            };\n        case FIBER_TAGS.FunctionalComponent:\n            return {\n                nodeType: 'function',\n                type: node.type,\n                props: { ...node.memoizedProps },\n                key: (0, enzyme_adapter_utils_1.ensureKeyOrUndefined)(node.key),\n                ref: node.ref,\n                instance: null,\n                rendered: childrenToTree(node.child),\n            };\n        case FIBER_TAGS.MemoClass:\n            return {\n                nodeType: 'class',\n                type: node.elementType.type,\n                props: { ...node.memoizedProps },\n                key: (0, enzyme_adapter_utils_1.ensureKeyOrUndefined)(node.key),\n                ref: node.ref,\n                instance: node.stateNode,\n                rendered: childrenToTree(node.child.child),\n            };\n        case FIBER_TAGS.MemoSFC: {\n            let renderedNodes = flatten(nodeAndSiblingsArray(node.child).map(toTree));\n            if (renderedNodes.length === 0) {\n                renderedNodes = [node.memoizedProps.children];\n            }\n            return {\n                nodeType: 'function',\n                type: node.elementType,\n                props: { ...node.memoizedProps },\n                key: (0, enzyme_adapter_utils_1.ensureKeyOrUndefined)(node.key),\n                ref: node.ref,\n                instance: null,\n                rendered: renderedNodes,\n            };\n        }\n        case FIBER_TAGS.HostComponent: {\n            let renderedNodes = flatten(nodeAndSiblingsArray(node.child).map(toTree));\n            if (renderedNodes.length === 0) {\n                renderedNodes = [node.memoizedProps.children];\n            }\n            return {\n                nodeType: 'host',\n                type: node.type,\n                props: { ...node.memoizedProps },\n                key: (0, enzyme_adapter_utils_1.ensureKeyOrUndefined)(node.key),\n                ref: node.ref,\n                instance: node.stateNode,\n                rendered: renderedNodes,\n            };\n        }\n        case FIBER_TAGS.HostText:\n            return node.memoizedProps;\n        case FIBER_TAGS.Fragment:\n        case FIBER_TAGS.Mode:\n        case FIBER_TAGS.ContextProvider:\n        case FIBER_TAGS.ContextConsumer:\n            return childrenToTree(node.child);\n        case FIBER_TAGS.Profiler:\n        case FIBER_TAGS.ForwardRef: {\n            return {\n                nodeType: 'function',\n                type: node.type,\n                props: { ...node.pendingProps },\n                key: (0, enzyme_adapter_utils_1.ensureKeyOrUndefined)(node.key),\n                ref: node.ref,\n                instance: null,\n                rendered: childrenToTree(node.child),\n            };\n        }\n        case FIBER_TAGS.Suspense: {\n            return {\n                nodeType: 'function',\n                type: react_is_1.Suspense,\n                props: { ...node.memoizedProps },\n                key: (0, enzyme_adapter_utils_1.ensureKeyOrUndefined)(node.key),\n                ref: node.ref,\n                instance: null,\n                rendered: childrenToTree(node.child),\n            };\n        }\n        case FIBER_TAGS.Lazy:\n            return childrenToTree(node.child);\n        case FIBER_TAGS.OffscreenComponent:\n            return toTree(node.child);\n        default:\n            throw new Error(`Enzyme Internal Error: unknown node with tag ${node.tag}`);\n    }\n}\nfunction childrenToTree(node) {\n    if (!node) {\n        return null;\n    }\n    const children = nodeAndSiblingsArray(node);\n    if (children.length === 0) {\n        return null;\n    }\n    if (children.length === 1) {\n        return toTree(children[0]);\n    }\n    return flatten(children.map(toTree));\n}\nfunction nodeToHostNode(_node) {\n    // NOTE(lmr): node could be a function component\n    // which wont have an instance prop, but we can get the\n    // host node associated with its return value at that point.\n    // Although this breaks down if the return value is an array,\n    // as is possible with React 16.\n    let node = _node;\n    while (node && !Array.isArray(node) && node.instance === null) {\n        node = node.rendered;\n    }\n    // if the SFC returned null effectively, there is no host node.\n    if (!node) {\n        return null;\n    }\n    const mapper = (item) => {\n        if (item && item.instance)\n            return react_dom_1.default.findDOMNode(item.instance);\n        return null;\n    };\n    if (Array.isArray(node)) {\n        return node.map(mapper);\n    }\n    if (Array.isArray(node.rendered) && node.nodeType === 'class') {\n        return node.rendered.map(mapper);\n    }\n    return mapper(node);\n}\nfunction replaceLazyWithFallback(node, fallback) {\n    if (!node) {\n        return null;\n    }\n    if (Array.isArray(node)) {\n        return node.map((el) => replaceLazyWithFallback(el, fallback));\n    }\n    if (isLazy(node.type)) {\n        return fallback;\n    }\n    return {\n        ...node,\n        props: {\n            ...node.props,\n            children: replaceLazyWithFallback(node.props.children, fallback),\n        },\n    };\n}\nfunction getEmptyStateValue() {\n    // this handles a bug in React 16.0 - 16.2\n    // see https://github.com/facebook/react/commit/39be83565c65f9c522150e52375167568a2a1459\n    // also see https://github.com/facebook/react/pull/11965\n    class EmptyState extends react_1.default.Component {\n        render() {\n            return null;\n        }\n    }\n    const testRenderer = new shallow_1.default();\n    testRenderer.render(react_1.default.createElement(EmptyState));\n    return testRenderer._instance.state;\n}\n// @ts-ignore\nconst wrapAct = react_1.default.unstable_act || test_utils_1.default.act;\nfunction getProviderDefaultValue(Provider) {\n    // React stores references to the Provider's defaultValue differently across versions.\n    if ('_defaultValue' in Provider._context) {\n        return Provider._context._defaultValue;\n    }\n    if ('_currentValue' in Provider._context) {\n        return Provider._context._currentValue;\n    }\n    throw new Error('Enzyme Internal Error: can’t figure out how to get Provider’s default value');\n}\nfunction makeFakeElement(type) {\n    return { $$typeof: react_is_1.Element, type };\n}\nfunction isStateful(Component) {\n    return (Component.prototype &&\n        (Component.prototype.isReactComponent || Array.isArray(Component.__reactAutoBindPairs)) // fallback for createClass components\n    );\n}\nclass ReactEighteenAdapter extends enzyme_1.EnzymeAdapter {\n    constructor() {\n        super();\n        // @ts-expect-error\n        const { lifecycles } = this.options;\n        // @ts-expect-error\n        this.options = {\n            // @ts-expect-error\n            ...this.options,\n            enableComponentDidUpdateOnSetState: true,\n            legacyContextMode: 'parent',\n            lifecycles: {\n                ...lifecycles,\n                componentDidUpdate: {\n                    onSetState: true,\n                },\n                getDerivedStateFromProps: {\n                    hasShouldComponentUpdateBug: false,\n                },\n                getSnapshotBeforeUpdate: true,\n                setState: {\n                    skipsComponentDidUpdateOnNullish: true,\n                },\n                getChildContext: {\n                    calledByRenderer: false,\n                },\n                getDerivedStateFromError: true,\n            },\n        };\n    }\n    createMountRenderer(options) {\n        globalThis.IS_REACT_ACT_ENVIRONMENT = true;\n        (0, enzyme_adapter_utils_1.assertDomAvailable)('mount');\n        if ((0, has_1.default)(options, 'suspenseFallback')) {\n            throw new TypeError('`suspenseFallback` is not supported by the `mount` renderer');\n        }\n        const { attachTo, hydrateIn, wrappingComponentProps } = options;\n        const domNode = hydrateIn || attachTo || global.document.createElement('div');\n        let instance = null;\n        let rootNode = null;\n        const adapter = this;\n        let unmountFlag = false;\n        return {\n            render(el, context, callback) {\n                return wrapAct(() => {\n                    if (instance === null) {\n                        const { type, props, ref } = el;\n                        const wrapperProps = {\n                            Component: type,\n                            props,\n                            wrappingComponentProps,\n                            context,\n                            onRenderCb: (that) => { instance = that; },\n                            ...(ref && { refProp: ref }),\n                        };\n                        const ReactWrapperComponent = (0, enzyme_adapter_utils_1.createMountWrapper)(el, { ...options, adapter });\n                        const wrappedEl = react_1.default.createElement(ReactWrapperComponent, wrapperProps);\n                        if (hydrateIn) {\n                            rootNode = (0, client_1.hydrateRoot)(domNode);\n                        }\n                        else {\n                            rootNode = (0, client_1.createRoot)(domNode);\n                        }\n                        rootNode.render(wrappedEl);\n                        // console.log('rendering to', { rootNode });\n                        if (typeof callback === 'function') {\n                            callback();\n                        }\n                    }\n                    else {\n                        instance.setChildProps(el.props, context, callback);\n                    }\n                });\n            },\n            unmount() {\n                // ReactWrapper calls getNode after unmounting, which will try to get nodes\n                // un an unmounted tree. So we flag it instead.\n                unmountFlag = true;\n            },\n            getNode() {\n                let node;\n                // Many node types will not have an instance (like functional components), should we consider throwing a user facing error here?\n                if (!instance) {\n                    node = null;\n                }\n                else {\n                    node = (0, enzyme_adapter_utils_1.getNodeFromRootFinder)(adapter.isCustomComponent, toTree(instance._reactInternals), options);\n                }\n                if (unmountFlag) {\n                    wrapAct(() => {\n                        rootNode === null || rootNode === void 0 ? void 0 : rootNode.unmount();\n                        instance = null;\n                    });\n                }\n                return node;\n            },\n            wrap: wrapAct,\n            simulateError(nodeHierarchy, rootNode, error) {\n                const isErrorBoundary = ({ instance: elInstance, type }) => {\n                    if (type && type.getDerivedStateFromError) {\n                        return true;\n                    }\n                    return elInstance && elInstance.componentDidCatch;\n                };\n                const { instance: catchingInstance, type: catchingType } = nodeHierarchy.find(isErrorBoundary) || {};\n                wrapAct(() => {\n                    (0, enzyme_adapter_utils_1.simulateError)(error, catchingInstance, rootNode, nodeHierarchy, nodeTypeFromType, adapter.displayNameOfNode, catchingType);\n                });\n            },\n            async simulateEvent(node, event, mock) {\n                const hostNode = adapter.nodeToHostNode(node);\n                const mappedEvent = (0, enzyme_adapter_utils_1.mapNativeEventNames)(event);\n                const eventFn = test_utils_1.default.Simulate[mappedEvent];\n                // console.log('Simulate on', hostNode, mock);\n                if (!eventFn) {\n                    throw new TypeError(`ReactWrapper::simulate() event '${event}' does not exist`);\n                }\n                await wrapAct(() => {\n                    eventFn(hostNode, mock);\n                });\n            },\n            batchedUpdates: react_dom_1.default.unstable_batchedUpdates,\n            getWrappingComponentRenderer() {\n                return {\n                    ...this,\n                    ...(0, enzyme_adapter_utils_1.getWrappingComponentMountRenderer)({\n                        toTree: (inst) => toTree(inst._reactInternals),\n                        getMountWrapperInstance: () => instance,\n                    }),\n                };\n            },\n            wrapInvoke: wrapAct,\n        };\n    }\n    createShallowRenderer(options = {}) {\n        const adapter = this;\n        const renderer = new shallow_1.default();\n        // @ts-expect-error\n        const { suspenseFallback } = options;\n        if (typeof suspenseFallback !== 'undefined' && typeof suspenseFallback !== 'boolean') {\n            throw TypeError('`options.suspenseFallback` should be boolean or undefined');\n        }\n        let isDOM = false;\n        let cachedNode = null;\n        let lastComponent = null;\n        let wrappedComponent = null;\n        const sentinel = {};\n        // wrap memo components with a PureComponent, or a class component with sCU\n        const wrapPureComponent = (Component, compare) => {\n            if (lastComponent !== Component) {\n                if (isStateful(Component)) {\n                    wrappedComponent = class extends Component {\n                    };\n                    if (compare) {\n                        // @ts-expect-error\n                        wrappedComponent.prototype.shouldComponentUpdate = (nextProps) => !compare(this.props, nextProps);\n                    }\n                    else {\n                        wrappedComponent.prototype.isPureReactComponent = true;\n                    }\n                }\n                else {\n                    let memoized = sentinel;\n                    let prevProps;\n                    wrappedComponent = function wrappedComponentFn(props, ...args) {\n                        const shouldUpdate = memoized === sentinel ||\n                            (compare ? !compare(prevProps, props) : !(0, enzyme_shallow_equal_1.default)(prevProps, props));\n                        if (shouldUpdate) {\n                            memoized = Component({ ...Component.defaultProps, ...props }, ...args);\n                            prevProps = props;\n                        }\n                        return memoized;\n                    };\n                }\n                Object.assign(wrappedComponent, Component, {\n                    displayName: adapter.displayNameOfNode({ type: Component }),\n                });\n                lastComponent = Component;\n            }\n            return wrappedComponent;\n        };\n        // Wrap functional components on versions prior to 16.5,\n        // to avoid inadvertently pass a `this` instance to it.\n        const wrapFunctionalComponent = (Component) => {\n            if ((0, has_1.default)(Component, 'defaultProps')) {\n                if (lastComponent !== Component) {\n                    wrappedComponent = Object.assign((props, ...args) => Component({ ...Component.defaultProps, ...props }, ...args), Component, { displayName: adapter.displayNameOfNode({ type: Component }) });\n                    lastComponent = Component;\n                }\n                return wrappedComponent;\n            }\n            return Component;\n        };\n        const renderElement = (elConfig, ...rest) => {\n            const renderedEl = renderer.render(elConfig, ...rest);\n            const typeIsExisted = !!(renderedEl && renderedEl.type);\n            if (typeIsExisted) {\n                const clonedEl = checkIsSuspenseAndCloneElement(renderedEl, { suspenseFallback });\n                const elementIsChanged = clonedEl.type !== renderedEl.type;\n                if (elementIsChanged) {\n                    return renderer.render({ ...elConfig, type: clonedEl.type }, ...rest);\n                }\n            }\n            return renderedEl;\n        };\n        return {\n            render(el, unmaskedContext, { providerValues = new Map() } = {}) {\n                cachedNode = el;\n                if (typeof el.type === 'string') {\n                    isDOM = true;\n                }\n                else if ((0, react_is_1.isContextProvider)(el)) {\n                    providerValues.set(el.type, el.props.value);\n                    const MockProvider = Object.assign((props) => props.children, el.type);\n                    return (0, enzyme_adapter_utils_1.withSetStateAllowed)(() => renderElement({ ...el, type: MockProvider }));\n                }\n                else if ((0, react_is_1.isContextConsumer)(el)) {\n                    const Provider = adapter.getProviderFromConsumer(el.type);\n                    const value = providerValues.has(Provider)\n                        ? providerValues.get(Provider)\n                        : getProviderDefaultValue(Provider);\n                    const MockConsumer = Object.assign((props) => props.children(value), el.type);\n                    return (0, enzyme_adapter_utils_1.withSetStateAllowed)(() => renderElement({ ...el, type: MockConsumer }));\n                }\n                else {\n                    isDOM = false;\n                    let renderedEl = el;\n                    if (isLazy(renderedEl)) {\n                        throw TypeError('`React.lazy` is not supported by shallow rendering.');\n                    }\n                    renderedEl = checkIsSuspenseAndCloneElement(renderedEl, { suspenseFallback });\n                    const { type: Component } = renderedEl;\n                    const context = (0, enzyme_adapter_utils_1.getMaskedContext)(Component.contextTypes, unmaskedContext);\n                    if (isMemo(el.type)) {\n                        const { type: InnerComp, compare } = el.type;\n                        return (0, enzyme_adapter_utils_1.withSetStateAllowed)(() => renderElement({ ...el, type: wrapPureComponent(InnerComp, compare) }, context));\n                    }\n                    const isComponentStateful = isStateful(Component);\n                    if (!isComponentStateful && typeof Component === 'function') {\n                        return (0, enzyme_adapter_utils_1.withSetStateAllowed)(() => renderElement({ ...renderedEl, type: wrapFunctionalComponent(Component) }, context));\n                    }\n                    if (isComponentStateful) {\n                        if (renderer._instance &&\n                            el.props === renderer._instance.props &&\n                            !(0, enzyme_shallow_equal_1.default)(context, renderer._instance.context)) {\n                            const { restore } = (0, enzyme_adapter_utils_1.spyMethod)(renderer, '_updateClassComponent', (originalMethod) => function _updateClassComponent(...args) {\n                                const { props } = renderer._instance;\n                                const clonedProps = { ...props };\n                                renderer._instance.props = clonedProps;\n                                const result = originalMethod.apply(renderer, args);\n                                renderer._instance.props = props;\n                                restore();\n                                return result;\n                            });\n                        }\n                        // fix react bug; see implementation of `getEmptyStateValue`\n                        const emptyStateValue = getEmptyStateValue();\n                        if (emptyStateValue) {\n                            Object.defineProperty(Component.prototype, 'state', {\n                                configurable: true,\n                                enumerable: true,\n                                get() {\n                                    return null;\n                                },\n                                set(value) {\n                                    if (value !== emptyStateValue) {\n                                        Object.defineProperty(this, 'state', {\n                                            configurable: true,\n                                            enumerable: true,\n                                            value,\n                                            writable: true,\n                                        });\n                                    }\n                                },\n                            });\n                        }\n                    }\n                    return (0, enzyme_adapter_utils_1.withSetStateAllowed)(() => renderElement(renderedEl, context));\n                }\n            },\n            unmount() {\n                renderer.unmount();\n            },\n            getNode() {\n                if (isDOM) {\n                    return elementToTree(cachedNode);\n                }\n                const output = renderer.getRenderOutput();\n                return {\n                    nodeType: nodeTypeFromType(cachedNode.type),\n                    type: cachedNode.type,\n                    props: cachedNode.props,\n                    key: (0, enzyme_adapter_utils_1.ensureKeyOrUndefined)(cachedNode.key),\n                    ref: cachedNode.ref,\n                    instance: renderer._instance,\n                    rendered: Array.isArray(output)\n                        ? flatten(output).map((el) => elementToTree(el))\n                        : elementToTree(output),\n                };\n            },\n            simulateError(nodeHierarchy, rootNode, error) {\n                (0, enzyme_adapter_utils_1.simulateError)(error, renderer._instance, cachedNode, nodeHierarchy.concat(cachedNode), nodeTypeFromType, adapter.displayNameOfNode, cachedNode.type);\n            },\n            simulateEvent(node, event, ...args) {\n                const handler = node.props[(0, enzyme_adapter_utils_1.propFromEvent)(event)];\n                if (handler) {\n                    (0, enzyme_adapter_utils_1.withSetStateAllowed)(() => {\n                        // TODO(lmr): create/use synthetic events\n                        // TODO(lmr): emulate React's event propagation\n                        // ReactDOM.unstable_batchedUpdates(() => {\n                        handler(...args);\n                        // });\n                    });\n                }\n            },\n            batchedUpdates(fn) {\n                return fn();\n                // return ReactDOM.unstable_batchedUpdates(fn);\n            },\n            // checkPropTypes(typeSpecs, values, location, hierarchy) {\n            //   return checkPropTypes(typeSpecs, values, location, displayNameOfNode(cachedNode), () =>\n            //     getComponentStack(hierarchy.concat([cachedNode])),);\n            // },\n            checkPropTypes(typeSpecs, values, location, hierarchy) {\n                return true;\n            },\n        };\n    }\n    createStringRenderer(options) {\n        if ((0, has_1.default)(options, 'suspenseFallback')) {\n            throw new TypeError('`suspenseFallback` should not be specified in options of string renderer');\n        }\n        // JSDOM >= 17 has begun removing Node API's from global.\n        // To avoid having to change environment for specific tests, it makes sense to globally 'polyfil' these after the fact.\n        if (!globalThis.TextEncoder) {\n            throw new Error(`Using Jest and/or JSDOM? TextEncoder needs to be available in the \\`global\\` scope to use Enzyme.render(<Component />).\nAdd the following to your test suite setup file (\"setupfile\" option in Jest), to polyfill it:\n\\`\\`\\`\n  import util from 'util';\n  Object.defineProperty(global, 'TextEncoder', {\n    value: util.TextEncoder,\n  });\n\\`\\`\\``);\n        }\n        const ReactDOMServer = require('react-dom/server');\n        return {\n            render(el, context) {\n                if (options.context && (el.type.contextTypes || options.childContextTypes)) {\n                    const childContextTypes = {\n                        ...(el.type.contextTypes || {}),\n                        ...options.childContextTypes,\n                    };\n                    const ContextWrapper = (0, enzyme_adapter_utils_1.createRenderWrapper)(el, context, childContextTypes);\n                    return ReactDOMServer.renderToStaticMarkup(react_1.default.createElement(ContextWrapper));\n                }\n                return ReactDOMServer.renderToStaticMarkup(el);\n            },\n        };\n    }\n    // Provided a bag of options, return an `EnzymeRenderer`. Some options can be implementation\n    // specific, like `attach` etc. for React, but not part of this interface explicitly.\n    createRenderer(options) {\n        switch (options.mode) {\n            // @ts-expect-error\n            case enzyme_1.EnzymeAdapter.MODES.MOUNT: // enzyme.mount()\n                return this.createMountRenderer(options);\n            // @ts-expect-error\n            case enzyme_1.EnzymeAdapter.MODES.SHALLOW: // enzyme.shallow()\n                return this.createShallowRenderer(options);\n            // @ts-expect-error\n            case enzyme_1.EnzymeAdapter.MODES.STRING: // enzyme.render()\n                return this.createStringRenderer(options);\n            default:\n                throw new Error(`Enzyme Internal Error: Unrecognized mode: ${options.mode}`);\n        }\n    }\n    wrap(element) {\n        return (0, enzyme_adapter_utils_1.wrap)(element);\n    }\n    // converts an RSTNode to the corresponding JSX Pragma Element. This will be needed\n    // in order to implement the `Wrapper.mount()` and `Wrapper.shallow()` methods, but should\n    // be pretty straightforward for people to implement.\n    nodeToElement(node) {\n        if (!node || typeof node !== 'object')\n            return null;\n        const { type } = node;\n        return react_1.default.createElement(unmemoType(type), (0, enzyme_adapter_utils_1.propsWithKeysAndRef)(node));\n    }\n    matchesElementType(node, matchingType) {\n        if (!node) {\n            return node;\n        }\n        const { type } = node;\n        return unmemoType(type) === unmemoType(matchingType);\n    }\n    elementToNode(element) {\n        return elementToTree(element);\n    }\n    nodeToHostNode(node, supportsArray = false) {\n        const nodes = nodeToHostNode(node);\n        if (Array.isArray(nodes) && !supportsArray) {\n            // get the first non-null node\n            return nodes.filter(Boolean)[0];\n        }\n        return nodes;\n    }\n    displayNameOfNode(node) {\n        if (!node)\n            return null;\n        const { type, $$typeof } = node;\n        const adapter = this;\n        const nodeType = type || $$typeof;\n        // newer node types may be undefined, so only test if the nodeType exists\n        if (nodeType) {\n            switch (nodeType) {\n                case react_is_1.ConcurrentMode || NaN:\n                    return 'ConcurrentMode';\n                case react_is_1.Fragment || NaN:\n                    return 'Fragment';\n                case react_is_1.StrictMode || NaN:\n                    return 'StrictMode';\n                case react_is_1.Profiler || NaN:\n                    return 'Profiler';\n                case react_is_1.Portal || NaN:\n                    return 'Portal';\n                case react_is_1.Suspense || NaN:\n                    return 'Suspense';\n                default:\n            }\n        }\n        const $$typeofType = type && type.$$typeof;\n        switch ($$typeofType) {\n            case react_is_1.ContextConsumer || NaN:\n                return 'ContextConsumer';\n            case react_is_1.ContextProvider || NaN:\n                return 'ContextProvider';\n            case react_is_1.Memo || NaN: {\n                const nodeName = (0, enzyme_adapter_utils_1.displayNameOfNode)(node);\n                return typeof nodeName === 'string' ? nodeName : `Memo(${adapter.displayNameOfNode(type)})`;\n            }\n            case react_is_1.ForwardRef || NaN: {\n                if (type.displayName) {\n                    return type.displayName;\n                }\n                const name = adapter.displayNameOfNode({ type: type.render });\n                return name ? `ForwardRef(${name})` : 'ForwardRef';\n            }\n            case react_is_1.Lazy || NaN: {\n                return 'lazy';\n            }\n            default:\n                return (0, enzyme_adapter_utils_1.displayNameOfNode)(node);\n        }\n    }\n    isValidElement(element) {\n        return (0, react_is_1.isElement)(element);\n    }\n    isValidElementType(object) {\n        return !!object && (0, react_is_1.isValidElementType)(object);\n    }\n    isFragment(fragment) {\n        return (0, Utils_1.typeOfNode)(fragment) === react_is_1.Fragment;\n    }\n    isCustomComponent(type) {\n        const fakeElement = makeFakeElement(type);\n        return (!!type &&\n            (typeof type === 'function' ||\n                (0, react_is_1.isForwardRef)(fakeElement) ||\n                (0, react_is_1.isContextProvider)(fakeElement) ||\n                (0, react_is_1.isContextConsumer)(fakeElement) ||\n                (0, react_is_1.isSuspense)(fakeElement)));\n    }\n    isContextConsumer(type) {\n        return !!type && (0, react_is_1.isContextConsumer)(makeFakeElement(type));\n    }\n    isCustomComponentElement(inst) {\n        if (!inst || !this.isValidElement(inst)) {\n            return false;\n        }\n        return this.isCustomComponent(inst.type);\n    }\n    getProviderFromConsumer(Consumer) {\n        // React stores references to the Provider on a Consumer differently across versions.\n        if (Consumer) {\n            let Provider;\n            if (Consumer._context) {\n                // check this first, to avoid a deprecation warning\n                ({ Provider } = Consumer._context);\n            }\n            else if (Consumer.Provider) {\n                ({ Provider } = Consumer);\n            }\n            if (Provider) {\n                return Provider;\n            }\n        }\n        throw new Error('Enzyme Internal Error: can’t figure out how to get Provider from Consumer');\n    }\n    createElement(...args) {\n        // @ts-expect-error\n        return react_1.default.createElement(...args);\n    }\n    // @ts-expect-error\n    wrapWithWrappingComponent(node, options) {\n        return {\n            RootFinder: enzyme_adapter_utils_1.RootFinder,\n            node: (0, enzyme_adapter_utils_1.wrapWithWrappingComponent)(react_1.default.createElement, node, options),\n        };\n    }\n}\nexports.default = ReactEighteenAdapter;\n"],"mappings":"AAAA,YAAY;;AACZ,IAAIA,eAAe,GAAI,IAAI,IAAI,IAAI,CAACA,eAAe,IAAK,UAAUC,GAAG,EAAE;EACnE,OAAQA,GAAG,IAAIA,GAAG,CAACC,UAAU,GAAID,GAAG,GAAG;IAAE,SAAS,EAAEA;EAAI,CAAC;AAC7D,CAAC;AACDE,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7D;AACA;AACA,MAAMC,OAAO,GAAGP,eAAe,CAACQ,OAAO,CAAC,OAAO,CAAC,CAAC;AACjD,MAAMC,WAAW,GAAGT,eAAe,CAACQ,OAAO,CAAC,WAAW,CAAC,CAAC;AACzD,MAAME,QAAQ,GAAGF,OAAO,CAAC,kBAAkB,CAAC;AAC5C,MAAMG,SAAS,GAAGX,eAAe,CAACQ,OAAO,CAAC,6BAA6B,CAAC,CAAC;AACzE,MAAMI,YAAY,GAAGZ,eAAe,CAACQ,OAAO,CAAC,sBAAsB,CAAC,CAAC;AACrE,MAAMK,KAAK,GAAGb,eAAe,CAACQ,OAAO,CAAC,KAAK,CAAC,CAAC;AAC7C,MAAMM,UAAU,GAAGN,OAAO,CAAC,UAAU,CAAC;AACtC,MAAMO,QAAQ,GAAGP,OAAO,CAAC,QAAQ,CAAC;AAClC,MAAMQ,OAAO,GAAGR,OAAO,CAAC,oBAAoB,CAAC;AAC7C,MAAMS,sBAAsB,GAAGjB,eAAe,CAACQ,OAAO,CAAC,sBAAsB,CAAC,CAAC;AAC/E,MAAMU,sBAAsB,GAAGV,OAAO,CAAC,wBAAwB,CAAC;AAChE,MAAMW,+BAA+B,GAAGnB,eAAe,CAACQ,OAAO,CAAC,iCAAiC,CAAC,CAAC;AACnG,MAAMY,iBAAiB,GAAGpB,eAAe,CAACQ,OAAO,CAAC,mBAAmB,CAAC,CAAC;AACvE,MAAMa,UAAU,GAAG,CAAC,CAAC,EAAED,iBAAiB,CAACE,OAAO,EAAE,CAAC;AACnD,SAASC,oBAAoBA,CAACC,eAAe,EAAE;EAC3C,MAAMC,KAAK,GAAG,EAAE;EAChB,IAAIC,IAAI,GAAGF,eAAe;EAC1B,OAAOE,IAAI,IAAI,IAAI,EAAE;IACjBD,KAAK,CAACE,IAAI,CAACD,IAAI,CAAC;IAChBA,IAAI,GAAGA,IAAI,CAACE,OAAO;EACvB;EACA,OAAOH,KAAK;AAChB;AACA,SAASI,OAAOA,CAACC,GAAG,EAAE;EAClB,MAAMC,MAAM,GAAG,EAAE;EACjB,MAAMC,KAAK,GAAG,CAAC;IAAEC,CAAC,EAAE,CAAC;IAAER,KAAK,EAAEK;EAAI,CAAC,CAAC;EACpC,OAAOE,KAAK,CAACE,MAAM,EAAE;IACjB,MAAMC,CAAC,GAAGH,KAAK,CAACI,GAAG,CAAC,CAAC;IACrB,OAAOD,CAAC,CAACF,CAAC,GAAGE,CAAC,CAACV,KAAK,CAACS,MAAM,EAAE;MACzB,MAAMG,EAAE,GAAGF,CAAC,CAACV,KAAK,CAACU,CAAC,CAACF,CAAC,CAAC;MACvBE,CAAC,CAACF,CAAC,IAAI,CAAC;MACR,IAAIK,KAAK,CAACC,OAAO,CAACF,EAAE,CAAC,EAAE;QACnBL,KAAK,CAACL,IAAI,CAACQ,CAAC,CAAC;QACbH,KAAK,CAACL,IAAI,CAAC;UAAEM,CAAC,EAAE,CAAC;UAAER,KAAK,EAAEY;QAAG,CAAC,CAAC;QAC/B;MACJ;MACAN,MAAM,CAACJ,IAAI,CAACU,EAAE,CAAC;IACnB;EACJ;EACA,OAAON,MAAM;AACjB;AACA,SAASS,gBAAgBA,CAACC,IAAI,EAAE;EAC5B,IAAIA,IAAI,KAAK3B,UAAU,CAAC4B,MAAM,EAAE;IAC5B,OAAO,QAAQ;EACnB;EACA,OAAO,CAAC,CAAC,EAAExB,sBAAsB,CAACsB,gBAAgB,EAAEC,IAAI,CAAC;AAC7D;AACA,SAASE,MAAMA,CAACF,IAAI,EAAE;EAClB,OAAO,CAAC,CAAC,EAAEvB,sBAAsB,CAAC0B,iBAAiB,EAAEH,IAAI,EAAE3B,UAAU,CAAC+B,IAAI,CAAC;AAC/E;AACA,SAASC,MAAMA,CAACL,IAAI,EAAE;EAClB,OAAO,CAAC,CAAC,EAAEvB,sBAAsB,CAAC0B,iBAAiB,EAAEH,IAAI,EAAE3B,UAAU,CAACiC,IAAI,CAAC;AAC/E;AACA,SAASC,UAAUA,CAACP,IAAI,EAAE;EACtB,OAAOE,MAAM,CAACF,IAAI,CAAC,GAAGA,IAAI,CAACA,IAAI,GAAGA,IAAI;AAC1C;AACA,SAASQ,8BAA8BA,CAACZ,EAAE,EAAAa,IAAA,EAAwB;EAAA,IAAtB;IAAEC;EAAiB,CAAC,GAAAD,IAAA;EAC5D,IAAI,CAAC,CAAC,CAAC,EAAEpC,UAAU,CAACsC,UAAU,EAAEf,EAAE,CAAC,EAAE;IACjC,OAAOA,EAAE;EACb;EACA,IAAI;IAAEgB;EAAS,CAAC,GAAGhB,EAAE,CAACiB,KAAK;EAC3B,IAAIH,gBAAgB,EAAE;IAClB,MAAM;MAAEI;IAAS,CAAC,GAAGlB,EAAE,CAACiB,KAAK;IAC7BD,QAAQ,GAAGG,uBAAuB,CAACH,QAAQ,EAAEE,QAAQ,CAAC;EAC1D;EACA,SAASE,mBAAmBA,CAACH,KAAK,EAAE;IAChC,OAAO/C,OAAO,CAACe,OAAO,CAACoC,aAAa,CAACrB,EAAE,CAACI,IAAI,EAAE;MAAE,GAAGJ,EAAE,CAACiB,KAAK;MAAE,GAAGA;IAAM,CAAC,EAAED,QAAQ,CAAC;EACtF;EACA,OAAO9C,OAAO,CAACe,OAAO,CAACoC,aAAa,CAACD,mBAAmB,EAAE,IAAI,EAAEJ,QAAQ,CAAC;AAC7E;AACA,SAASM,aAAaA,CAACtB,EAAE,EAAE;EACvB,IAAI,CAAC,CAAC,CAAC,EAAEvB,UAAU,CAAC8C,QAAQ,EAAEvB,EAAE,CAAC,EAAE;IAC/B,OAAO,CAAC,CAAC,EAAEnB,sBAAsB,CAACyC,aAAa,EAAEtB,EAAE,EAAEsB,aAAa,CAAC;EACvE;EACA,MAAM;IAAEN,QAAQ;IAAEQ;EAAc,CAAC,GAAGxB,EAAE;EACtC,MAAMiB,KAAK,GAAG;IAAED,QAAQ;IAAEQ;EAAc,CAAC;EACzC,OAAO;IACHC,QAAQ,EAAE,QAAQ;IAClBrB,IAAI,EAAE3B,UAAU,CAAC4B,MAAM;IACvBY,KAAK;IACLS,GAAG,EAAE,CAAC,CAAC,EAAE7C,sBAAsB,CAAC8C,oBAAoB,EAAE3B,EAAE,CAAC0B,GAAG,CAAC;IAC7DE,GAAG,EAAE5B,EAAE,CAAC4B,GAAG,IAAI,IAAI;IACnBC,QAAQ,EAAE,IAAI;IACdC,QAAQ,EAAER,aAAa,CAACtB,EAAE,CAACgB,QAAQ;EACvC,CAAC;AACL;AACA,SAASe,MAAMA,CAACC,KAAK,EAAE;EACnB,IAAIA,KAAK,IAAI,IAAI,EAAE;IACf,OAAO,IAAI;EACf;EACA;EACA;EACA;EACA,MAAM3C,IAAI,GAAG,CAAC,CAAC,EAAEP,+BAA+B,CAACG,OAAO,EAAE+C,KAAK,CAAC;EAChE,QAAQ3C,IAAI,CAAC4C,GAAG;IACZ,KAAKjD,UAAU,CAACkD,QAAQ;MACpB,OAAOC,cAAc,CAAC9C,IAAI,CAAC+C,KAAK,CAAC;IACrC,KAAKpD,UAAU,CAACqD,UAAU;MAAE;QACxB,MAAM;UAAEC,SAAS,EAAE;YAAEd;UAAc,CAAC;UAAEe,aAAa,EAAEvB;QAAU,CAAC,GAAG3B,IAAI;QACvE,MAAM4B,KAAK,GAAG;UAAEO,aAAa;UAAER;QAAS,CAAC;QACzC,OAAO;UACHS,QAAQ,EAAE,QAAQ;UAClBrB,IAAI,EAAE3B,UAAU,CAAC4B,MAAM;UACvBY,KAAK;UACLS,GAAG,EAAE,CAAC,CAAC,EAAE7C,sBAAsB,CAAC8C,oBAAoB,EAAEtC,IAAI,CAACqC,GAAG,CAAC;UAC/DE,GAAG,EAAEvC,IAAI,CAACuC,GAAG;UACbC,QAAQ,EAAE,IAAI;UACdC,QAAQ,EAAEK,cAAc,CAAC9C,IAAI,CAAC+C,KAAK;QACvC,CAAC;MACL;IACA,KAAKpD,UAAU,CAACwD,cAAc;MAC1B,OAAO;QACHf,QAAQ,EAAE,OAAO;QACjBrB,IAAI,EAAEf,IAAI,CAACe,IAAI;QACfa,KAAK,EAAE;UAAE,GAAG5B,IAAI,CAACkD;QAAc,CAAC;QAChCb,GAAG,EAAE,CAAC,CAAC,EAAE7C,sBAAsB,CAAC8C,oBAAoB,EAAEtC,IAAI,CAACqC,GAAG,CAAC;QAC/DE,GAAG,EAAEvC,IAAI,CAACuC,GAAG;QACbC,QAAQ,EAAExC,IAAI,CAACiD,SAAS;QACxBR,QAAQ,EAAEK,cAAc,CAAC9C,IAAI,CAAC+C,KAAK;MACvC,CAAC;IACL,KAAKpD,UAAU,CAACyD,mBAAmB;MAC/B,OAAO;QACHhB,QAAQ,EAAE,UAAU;QACpBrB,IAAI,EAAEf,IAAI,CAACe,IAAI;QACfa,KAAK,EAAE;UAAE,GAAG5B,IAAI,CAACkD;QAAc,CAAC;QAChCb,GAAG,EAAE,CAAC,CAAC,EAAE7C,sBAAsB,CAAC8C,oBAAoB,EAAEtC,IAAI,CAACqC,GAAG,CAAC;QAC/DE,GAAG,EAAEvC,IAAI,CAACuC,GAAG;QACbC,QAAQ,EAAE,IAAI;QACdC,QAAQ,EAAEK,cAAc,CAAC9C,IAAI,CAAC+C,KAAK;MACvC,CAAC;IACL,KAAKpD,UAAU,CAAC0D,SAAS;MACrB,OAAO;QACHjB,QAAQ,EAAE,OAAO;QACjBrB,IAAI,EAAEf,IAAI,CAACsD,WAAW,CAACvC,IAAI;QAC3Ba,KAAK,EAAE;UAAE,GAAG5B,IAAI,CAACkD;QAAc,CAAC;QAChCb,GAAG,EAAE,CAAC,CAAC,EAAE7C,sBAAsB,CAAC8C,oBAAoB,EAAEtC,IAAI,CAACqC,GAAG,CAAC;QAC/DE,GAAG,EAAEvC,IAAI,CAACuC,GAAG;QACbC,QAAQ,EAAExC,IAAI,CAACiD,SAAS;QACxBR,QAAQ,EAAEK,cAAc,CAAC9C,IAAI,CAAC+C,KAAK,CAACA,KAAK;MAC7C,CAAC;IACL,KAAKpD,UAAU,CAAC4D,OAAO;MAAE;QACrB,IAAIC,aAAa,GAAGrD,OAAO,CAACN,oBAAoB,CAACG,IAAI,CAAC+C,KAAK,CAAC,CAACU,GAAG,CAACf,MAAM,CAAC,CAAC;QACzE,IAAIc,aAAa,CAAChD,MAAM,KAAK,CAAC,EAAE;UAC5BgD,aAAa,GAAG,CAACxD,IAAI,CAACkD,aAAa,CAACvB,QAAQ,CAAC;QACjD;QACA,OAAO;UACHS,QAAQ,EAAE,UAAU;UACpBrB,IAAI,EAAEf,IAAI,CAACsD,WAAW;UACtB1B,KAAK,EAAE;YAAE,GAAG5B,IAAI,CAACkD;UAAc,CAAC;UAChCb,GAAG,EAAE,CAAC,CAAC,EAAE7C,sBAAsB,CAAC8C,oBAAoB,EAAEtC,IAAI,CAACqC,GAAG,CAAC;UAC/DE,GAAG,EAAEvC,IAAI,CAACuC,GAAG;UACbC,QAAQ,EAAE,IAAI;UACdC,QAAQ,EAAEe;QACd,CAAC;MACL;IACA,KAAK7D,UAAU,CAAC+D,aAAa;MAAE;QAC3B,IAAIF,aAAa,GAAGrD,OAAO,CAACN,oBAAoB,CAACG,IAAI,CAAC+C,KAAK,CAAC,CAACU,GAAG,CAACf,MAAM,CAAC,CAAC;QACzE,IAAIc,aAAa,CAAChD,MAAM,KAAK,CAAC,EAAE;UAC5BgD,aAAa,GAAG,CAACxD,IAAI,CAACkD,aAAa,CAACvB,QAAQ,CAAC;QACjD;QACA,OAAO;UACHS,QAAQ,EAAE,MAAM;UAChBrB,IAAI,EAAEf,IAAI,CAACe,IAAI;UACfa,KAAK,EAAE;YAAE,GAAG5B,IAAI,CAACkD;UAAc,CAAC;UAChCb,GAAG,EAAE,CAAC,CAAC,EAAE7C,sBAAsB,CAAC8C,oBAAoB,EAAEtC,IAAI,CAACqC,GAAG,CAAC;UAC/DE,GAAG,EAAEvC,IAAI,CAACuC,GAAG;UACbC,QAAQ,EAAExC,IAAI,CAACiD,SAAS;UACxBR,QAAQ,EAAEe;QACd,CAAC;MACL;IACA,KAAK7D,UAAU,CAACgE,QAAQ;MACpB,OAAO3D,IAAI,CAACkD,aAAa;IAC7B,KAAKvD,UAAU,CAACiE,QAAQ;IACxB,KAAKjE,UAAU,CAACkE,IAAI;IACpB,KAAKlE,UAAU,CAACmE,eAAe;IAC/B,KAAKnE,UAAU,CAACoE,eAAe;MAC3B,OAAOjB,cAAc,CAAC9C,IAAI,CAAC+C,KAAK,CAAC;IACrC,KAAKpD,UAAU,CAACqE,QAAQ;IACxB,KAAKrE,UAAU,CAACsE,UAAU;MAAE;QACxB,OAAO;UACH7B,QAAQ,EAAE,UAAU;UACpBrB,IAAI,EAAEf,IAAI,CAACe,IAAI;UACfa,KAAK,EAAE;YAAE,GAAG5B,IAAI,CAACkE;UAAa,CAAC;UAC/B7B,GAAG,EAAE,CAAC,CAAC,EAAE7C,sBAAsB,CAAC8C,oBAAoB,EAAEtC,IAAI,CAACqC,GAAG,CAAC;UAC/DE,GAAG,EAAEvC,IAAI,CAACuC,GAAG;UACbC,QAAQ,EAAE,IAAI;UACdC,QAAQ,EAAEK,cAAc,CAAC9C,IAAI,CAAC+C,KAAK;QACvC,CAAC;MACL;IACA,KAAKpD,UAAU,CAACwE,QAAQ;MAAE;QACtB,OAAO;UACH/B,QAAQ,EAAE,UAAU;UACpBrB,IAAI,EAAE3B,UAAU,CAAC+E,QAAQ;UACzBvC,KAAK,EAAE;YAAE,GAAG5B,IAAI,CAACkD;UAAc,CAAC;UAChCb,GAAG,EAAE,CAAC,CAAC,EAAE7C,sBAAsB,CAAC8C,oBAAoB,EAAEtC,IAAI,CAACqC,GAAG,CAAC;UAC/DE,GAAG,EAAEvC,IAAI,CAACuC,GAAG;UACbC,QAAQ,EAAE,IAAI;UACdC,QAAQ,EAAEK,cAAc,CAAC9C,IAAI,CAAC+C,KAAK;QACvC,CAAC;MACL;IACA,KAAKpD,UAAU,CAAC0B,IAAI;MAChB,OAAOyB,cAAc,CAAC9C,IAAI,CAAC+C,KAAK,CAAC;IACrC,KAAKpD,UAAU,CAACyE,kBAAkB;MAC9B,OAAO1B,MAAM,CAAC1C,IAAI,CAAC+C,KAAK,CAAC;IAC7B;MACI,MAAM,IAAIsB,KAAK,CAAC,gDAAgDrE,IAAI,CAAC4C,GAAG,EAAE,CAAC;EACnF;AACJ;AACA,SAASE,cAAcA,CAAC9C,IAAI,EAAE;EAC1B,IAAI,CAACA,IAAI,EAAE;IACP,OAAO,IAAI;EACf;EACA,MAAM2B,QAAQ,GAAG9B,oBAAoB,CAACG,IAAI,CAAC;EAC3C,IAAI2B,QAAQ,CAACnB,MAAM,KAAK,CAAC,EAAE;IACvB,OAAO,IAAI;EACf;EACA,IAAImB,QAAQ,CAACnB,MAAM,KAAK,CAAC,EAAE;IACvB,OAAOkC,MAAM,CAACf,QAAQ,CAAC,CAAC,CAAC,CAAC;EAC9B;EACA,OAAOxB,OAAO,CAACwB,QAAQ,CAAC8B,GAAG,CAACf,MAAM,CAAC,CAAC;AACxC;AACA,SAAS4B,cAAcA,CAACC,KAAK,EAAE;EAC3B;EACA;EACA;EACA;EACA;EACA,IAAIvE,IAAI,GAAGuE,KAAK;EAChB,OAAOvE,IAAI,IAAI,CAACY,KAAK,CAACC,OAAO,CAACb,IAAI,CAAC,IAAIA,IAAI,CAACwC,QAAQ,KAAK,IAAI,EAAE;IAC3DxC,IAAI,GAAGA,IAAI,CAACyC,QAAQ;EACxB;EACA;EACA,IAAI,CAACzC,IAAI,EAAE;IACP,OAAO,IAAI;EACf;EACA,MAAMwE,MAAM,GAAIC,IAAI,IAAK;IACrB,IAAIA,IAAI,IAAIA,IAAI,CAACjC,QAAQ,EACrB,OAAOzD,WAAW,CAACa,OAAO,CAAC8E,WAAW,CAACD,IAAI,CAACjC,QAAQ,CAAC;IACzD,OAAO,IAAI;EACf,CAAC;EACD,IAAI5B,KAAK,CAACC,OAAO,CAACb,IAAI,CAAC,EAAE;IACrB,OAAOA,IAAI,CAACyD,GAAG,CAACe,MAAM,CAAC;EAC3B;EACA,IAAI5D,KAAK,CAACC,OAAO,CAACb,IAAI,CAACyC,QAAQ,CAAC,IAAIzC,IAAI,CAACoC,QAAQ,KAAK,OAAO,EAAE;IAC3D,OAAOpC,IAAI,CAACyC,QAAQ,CAACgB,GAAG,CAACe,MAAM,CAAC;EACpC;EACA,OAAOA,MAAM,CAACxE,IAAI,CAAC;AACvB;AACA,SAAS8B,uBAAuBA,CAAC9B,IAAI,EAAE6B,QAAQ,EAAE;EAC7C,IAAI,CAAC7B,IAAI,EAAE;IACP,OAAO,IAAI;EACf;EACA,IAAIY,KAAK,CAACC,OAAO,CAACb,IAAI,CAAC,EAAE;IACrB,OAAOA,IAAI,CAACyD,GAAG,CAAE9C,EAAE,IAAKmB,uBAAuB,CAACnB,EAAE,EAAEkB,QAAQ,CAAC,CAAC;EAClE;EACA,IAAIT,MAAM,CAACpB,IAAI,CAACe,IAAI,CAAC,EAAE;IACnB,OAAOc,QAAQ;EACnB;EACA,OAAO;IACH,GAAG7B,IAAI;IACP4B,KAAK,EAAE;MACH,GAAG5B,IAAI,CAAC4B,KAAK;MACbD,QAAQ,EAAEG,uBAAuB,CAAC9B,IAAI,CAAC4B,KAAK,CAACD,QAAQ,EAAEE,QAAQ;IACnE;EACJ,CAAC;AACL;AACA,SAAS8C,kBAAkBA,CAAA,EAAG;EAC1B;EACA;EACA;EACA,MAAMC,UAAU,SAAS/F,OAAO,CAACe,OAAO,CAACiF,SAAS,CAAC;IAC/CC,MAAMA,CAAA,EAAG;MACL,OAAO,IAAI;IACf;EACJ;EACA,MAAMC,YAAY,GAAG,IAAI9F,SAAS,CAACW,OAAO,CAAC,CAAC;EAC5CmF,YAAY,CAACD,MAAM,CAACjG,OAAO,CAACe,OAAO,CAACoC,aAAa,CAAC4C,UAAU,CAAC,CAAC;EAC9D,OAAOG,YAAY,CAACC,SAAS,CAACC,KAAK;AACvC;AACA;AACA,MAAMC,OAAO,GAAGrG,OAAO,CAACe,OAAO,CAACuF,YAAY,IAAIjG,YAAY,CAACU,OAAO,CAACwF,GAAG;AACxE,SAASC,uBAAuBA,CAACC,QAAQ,EAAE;EACvC;EACA,IAAI,eAAe,IAAIA,QAAQ,CAACC,QAAQ,EAAE;IACtC,OAAOD,QAAQ,CAACC,QAAQ,CAACC,aAAa;EAC1C;EACA,IAAI,eAAe,IAAIF,QAAQ,CAACC,QAAQ,EAAE;IACtC,OAAOD,QAAQ,CAACC,QAAQ,CAACE,aAAa;EAC1C;EACA,MAAM,IAAIpB,KAAK,CAAC,6EAA6E,CAAC;AAClG;AACA,SAASqB,eAAeA,CAAC3E,IAAI,EAAE;EAC3B,OAAO;IAAE4E,QAAQ,EAAEvG,UAAU,CAACwG,OAAO;IAAE7E;EAAK,CAAC;AACjD;AACA,SAAS8E,UAAUA,CAAChB,SAAS,EAAE;EAC3B,OAAQA,SAAS,CAACiB,SAAS,KACtBjB,SAAS,CAACiB,SAAS,CAACC,gBAAgB,IAAInF,KAAK,CAACC,OAAO,CAACgE,SAAS,CAACmB,oBAAoB,CAAC,CAAC,CAAC;EAAA;AAEhG;AACA,MAAMC,oBAAoB,SAAS5G,QAAQ,CAAC6G,aAAa,CAAC;EACtDC,WAAWA,CAAA,EAAG;IACV,KAAK,CAAC,CAAC;IACP;IACA,MAAM;MAAEC;IAAW,CAAC,GAAG,IAAI,CAACC,OAAO;IACnC;IACA,IAAI,CAACA,OAAO,GAAG;MACX;MACA,GAAG,IAAI,CAACA,OAAO;MACfC,kCAAkC,EAAE,IAAI;MACxCC,iBAAiB,EAAE,QAAQ;MAC3BH,UAAU,EAAE;QACR,GAAGA,UAAU;QACbI,kBAAkB,EAAE;UAChBC,UAAU,EAAE;QAChB,CAAC;QACDC,wBAAwB,EAAE;UACtBC,2BAA2B,EAAE;QACjC,CAAC;QACDC,uBAAuB,EAAE,IAAI;QAC7BC,QAAQ,EAAE;UACNC,gCAAgC,EAAE;QACtC,CAAC;QACDC,eAAe,EAAE;UACbC,gBAAgB,EAAE;QACtB,CAAC;QACDC,wBAAwB,EAAE;MAC9B;IACJ,CAAC;EACL;EACAC,mBAAmBA,CAACb,OAAO,EAAE;IACzBc,UAAU,CAACC,wBAAwB,GAAG,IAAI;IAC1C,CAAC,CAAC,EAAE5H,sBAAsB,CAAC6H,kBAAkB,EAAE,OAAO,CAAC;IACvD,IAAI,CAAC,CAAC,EAAElI,KAAK,CAACS,OAAO,EAAEyG,OAAO,EAAE,kBAAkB,CAAC,EAAE;MACjD,MAAM,IAAIiB,SAAS,CAAC,6DAA6D,CAAC;IACtF;IACA,MAAM;MAAEC,QAAQ;MAAEC,SAAS;MAAEC;IAAuB,CAAC,GAAGpB,OAAO;IAC/D,MAAMqB,OAAO,GAAGF,SAAS,IAAID,QAAQ,IAAII,MAAM,CAACC,QAAQ,CAAC5F,aAAa,CAAC,KAAK,CAAC;IAC7E,IAAIQ,QAAQ,GAAG,IAAI;IACnB,IAAIqF,QAAQ,GAAG,IAAI;IACnB,MAAMC,OAAO,GAAG,IAAI;IACpB,IAAIC,WAAW,GAAG,KAAK;IACvB,OAAO;MACHjD,MAAMA,CAACnE,EAAE,EAAEqH,OAAO,EAAEC,QAAQ,EAAE;QAC1B,OAAO/C,OAAO,CAAC,MAAM;UACjB,IAAI1C,QAAQ,KAAK,IAAI,EAAE;YACnB,MAAM;cAAEzB,IAAI;cAAEa,KAAK;cAAEW;YAAI,CAAC,GAAG5B,EAAE;YAC/B,MAAMuH,YAAY,GAAG;cACjBrD,SAAS,EAAE9D,IAAI;cACfa,KAAK;cACL6F,sBAAsB;cACtBO,OAAO;cACPG,UAAU,EAAGC,IAAI,IAAK;gBAAE5F,QAAQ,GAAG4F,IAAI;cAAE,CAAC;cAC1C,IAAI7F,GAAG,IAAI;gBAAE8F,OAAO,EAAE9F;cAAI,CAAC;YAC/B,CAAC;YACD,MAAM+F,qBAAqB,GAAG,CAAC,CAAC,EAAE9I,sBAAsB,CAAC+I,kBAAkB,EAAE5H,EAAE,EAAE;cAAE,GAAG0F,OAAO;cAAEyB;YAAQ,CAAC,CAAC;YACzG,MAAMU,SAAS,GAAG3J,OAAO,CAACe,OAAO,CAACoC,aAAa,CAACsG,qBAAqB,EAAEJ,YAAY,CAAC;YACpF,IAAIV,SAAS,EAAE;cACXK,QAAQ,GAAG,CAAC,CAAC,EAAE7I,QAAQ,CAACyJ,WAAW,EAAEf,OAAO,CAAC;YACjD,CAAC,MACI;cACDG,QAAQ,GAAG,CAAC,CAAC,EAAE7I,QAAQ,CAAC0J,UAAU,EAAEhB,OAAO,CAAC;YAChD;YACAG,QAAQ,CAAC/C,MAAM,CAAC0D,SAAS,CAAC;YAC1B;YACA,IAAI,OAAOP,QAAQ,KAAK,UAAU,EAAE;cAChCA,QAAQ,CAAC,CAAC;YACd;UACJ,CAAC,MACI;YACDzF,QAAQ,CAACmG,aAAa,CAAChI,EAAE,CAACiB,KAAK,EAAEoG,OAAO,EAAEC,QAAQ,CAAC;UACvD;QACJ,CAAC,CAAC;MACN,CAAC;MACDW,OAAOA,CAAA,EAAG;QACN;QACA;QACAb,WAAW,GAAG,IAAI;MACtB,CAAC;MACDc,OAAOA,CAAA,EAAG;QACN,IAAI7I,IAAI;QACR;QACA,IAAI,CAACwC,QAAQ,EAAE;UACXxC,IAAI,GAAG,IAAI;QACf,CAAC,MACI;UACDA,IAAI,GAAG,CAAC,CAAC,EAAER,sBAAsB,CAACsJ,qBAAqB,EAAEhB,OAAO,CAACiB,iBAAiB,EAAErG,MAAM,CAACF,QAAQ,CAACwG,eAAe,CAAC,EAAE3C,OAAO,CAAC;QAClI;QACA,IAAI0B,WAAW,EAAE;UACb7C,OAAO,CAAC,MAAM;YACV2C,QAAQ,KAAK,IAAI,IAAIA,QAAQ,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,QAAQ,CAACe,OAAO,CAAC,CAAC;YACtEpG,QAAQ,GAAG,IAAI;UACnB,CAAC,CAAC;QACN;QACA,OAAOxC,IAAI;MACf,CAAC;MACDiJ,IAAI,EAAE/D,OAAO;MACbgE,aAAaA,CAACC,aAAa,EAAEtB,QAAQ,EAAEuB,KAAK,EAAE;QAC1C,MAAMC,eAAe,GAAGC,KAAA,IAAoC;UAAA,IAAnC;YAAE9G,QAAQ,EAAE+G,UAAU;YAAExI;UAAK,CAAC,GAAAuI,KAAA;UACnD,IAAIvI,IAAI,IAAIA,IAAI,CAACkG,wBAAwB,EAAE;YACvC,OAAO,IAAI;UACf;UACA,OAAOsC,UAAU,IAAIA,UAAU,CAACC,iBAAiB;QACrD,CAAC;QACD,MAAM;UAAEhH,QAAQ,EAAEiH,gBAAgB;UAAE1I,IAAI,EAAE2I;QAAa,CAAC,GAAGP,aAAa,CAACQ,IAAI,CAACN,eAAe,CAAC,IAAI,CAAC,CAAC;QACpGnE,OAAO,CAAC,MAAM;UACV,CAAC,CAAC,EAAE1F,sBAAsB,CAAC0J,aAAa,EAAEE,KAAK,EAAEK,gBAAgB,EAAE5B,QAAQ,EAAEsB,aAAa,EAAErI,gBAAgB,EAAEgH,OAAO,CAAC8B,iBAAiB,EAAEF,YAAY,CAAC;QAC1J,CAAC,CAAC;MACN,CAAC;MACD,MAAMG,aAAaA,CAAC7J,IAAI,EAAE8J,KAAK,EAAEC,IAAI,EAAE;QACnC,MAAMC,QAAQ,GAAGlC,OAAO,CAACxD,cAAc,CAACtE,IAAI,CAAC;QAC7C,MAAMiK,WAAW,GAAG,CAAC,CAAC,EAAEzK,sBAAsB,CAAC0K,mBAAmB,EAAEJ,KAAK,CAAC;QAC1E,MAAMK,OAAO,GAAGjL,YAAY,CAACU,OAAO,CAACwK,QAAQ,CAACH,WAAW,CAAC;QAC1D;QACA,IAAI,CAACE,OAAO,EAAE;UACV,MAAM,IAAI7C,SAAS,CAAC,mCAAmCwC,KAAK,kBAAkB,CAAC;QACnF;QACA,MAAM5E,OAAO,CAAC,MAAM;UAChBiF,OAAO,CAACH,QAAQ,EAAED,IAAI,CAAC;QAC3B,CAAC,CAAC;MACN,CAAC;MACDM,cAAc,EAAEtL,WAAW,CAACa,OAAO,CAAC0K,uBAAuB;MAC3DC,4BAA4BA,CAAA,EAAG;QAC3B,OAAO;UACH,GAAG,IAAI;UACP,GAAG,CAAC,CAAC,EAAE/K,sBAAsB,CAACgL,iCAAiC,EAAE;YAC7D9H,MAAM,EAAG+H,IAAI,IAAK/H,MAAM,CAAC+H,IAAI,CAACzB,eAAe,CAAC;YAC9C0B,uBAAuB,EAAEA,CAAA,KAAMlI;UACnC,CAAC;QACL,CAAC;MACL,CAAC;MACDmI,UAAU,EAAEzF;IAChB,CAAC;EACL;EACA0F,qBAAqBA,CAAA,EAAe;IAAA,IAAdvE,OAAO,GAAAwE,SAAA,CAAArK,MAAA,QAAAqK,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,CAAC,CAAC;IAC9B,MAAM/C,OAAO,GAAG,IAAI;IACpB,MAAMiD,QAAQ,GAAG,IAAI9L,SAAS,CAACW,OAAO,CAAC,CAAC;IACxC;IACA,MAAM;MAAE6B;IAAiB,CAAC,GAAG4E,OAAO;IACpC,IAAI,OAAO5E,gBAAgB,KAAK,WAAW,IAAI,OAAOA,gBAAgB,KAAK,SAAS,EAAE;MAClF,MAAM6F,SAAS,CAAC,2DAA2D,CAAC;IAChF;IACA,IAAI0D,KAAK,GAAG,KAAK;IACjB,IAAIC,UAAU,GAAG,IAAI;IACrB,IAAIC,aAAa,GAAG,IAAI;IACxB,IAAIC,gBAAgB,GAAG,IAAI;IAC3B,MAAMC,QAAQ,GAAG,CAAC,CAAC;IACnB;IACA,MAAMC,iBAAiB,GAAGA,CAACxG,SAAS,EAAEyG,OAAO,KAAK;MAC9C,IAAIJ,aAAa,KAAKrG,SAAS,EAAE;QAC7B,IAAIgB,UAAU,CAAChB,SAAS,CAAC,EAAE;UACvBsG,gBAAgB,GAAG,cAActG,SAAS,CAAC,EAC1C;UACD,IAAIyG,OAAO,EAAE;YACT;YACAH,gBAAgB,CAACrF,SAAS,CAACyF,qBAAqB,GAAIC,SAAS,IAAK,CAACF,OAAO,CAAC,IAAI,CAAC1J,KAAK,EAAE4J,SAAS,CAAC;UACrG,CAAC,MACI;YACDL,gBAAgB,CAACrF,SAAS,CAAC2F,oBAAoB,GAAG,IAAI;UAC1D;QACJ,CAAC,MACI;UACD,IAAIC,QAAQ,GAAGN,QAAQ;UACvB,IAAIO,SAAS;UACbR,gBAAgB,GAAG,SAASS,kBAAkBA,CAAChK,KAAK,EAAW;YAC3D,MAAMiK,YAAY,GAAGH,QAAQ,KAAKN,QAAQ,KACrCE,OAAO,GAAG,CAACA,OAAO,CAACK,SAAS,EAAE/J,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,EAAErC,sBAAsB,CAACK,OAAO,EAAE+L,SAAS,EAAE/J,KAAK,CAAC,CAAC;YACnG,IAAIiK,YAAY,EAAE;cAAA,SAAAC,IAAA,GAAAjB,SAAA,CAAArK,MAAA,EAHmCuL,IAAI,OAAAnL,KAAA,CAAAkL,IAAA,OAAAA,IAAA,WAAAE,IAAA,MAAAA,IAAA,GAAAF,IAAA,EAAAE,IAAA;gBAAJD,IAAI,CAAAC,IAAA,QAAAnB,SAAA,CAAAmB,IAAA;cAAA;cAIrDN,QAAQ,GAAG7G,SAAS,CAAC;gBAAE,GAAGA,SAAS,CAACoH,YAAY;gBAAE,GAAGrK;cAAM,CAAC,EAAE,GAAGmK,IAAI,CAAC;cACtEJ,SAAS,GAAG/J,KAAK;YACrB;YACA,OAAO8J,QAAQ;UACnB,CAAC;QACL;QACAjN,MAAM,CAACyN,MAAM,CAACf,gBAAgB,EAAEtG,SAAS,EAAE;UACvCsH,WAAW,EAAErE,OAAO,CAAC8B,iBAAiB,CAAC;YAAE7I,IAAI,EAAE8D;UAAU,CAAC;QAC9D,CAAC,CAAC;QACFqG,aAAa,GAAGrG,SAAS;MAC7B;MACA,OAAOsG,gBAAgB;IAC3B,CAAC;IACD;IACA;IACA,MAAMiB,uBAAuB,GAAIvH,SAAS,IAAK;MAC3C,IAAI,CAAC,CAAC,EAAE1F,KAAK,CAACS,OAAO,EAAEiF,SAAS,EAAE,cAAc,CAAC,EAAE;QAC/C,IAAIqG,aAAa,KAAKrG,SAAS,EAAE;UAC7BsG,gBAAgB,GAAG1M,MAAM,CAACyN,MAAM,CAAC,UAACtK,KAAK;YAAA,SAAAyK,KAAA,GAAAxB,SAAA,CAAArK,MAAA,EAAKuL,IAAI,OAAAnL,KAAA,CAAAyL,KAAA,OAAAA,KAAA,WAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;cAAJP,IAAI,CAAAO,KAAA,QAAAzB,SAAA,CAAAyB,KAAA;YAAA;YAAA,OAAKzH,SAAS,CAAC;cAAE,GAAGA,SAAS,CAACoH,YAAY;cAAE,GAAGrK;YAAM,CAAC,EAAE,GAAGmK,IAAI,CAAC;UAAA,GAAElH,SAAS,EAAE;YAAEsH,WAAW,EAAErE,OAAO,CAAC8B,iBAAiB,CAAC;cAAE7I,IAAI,EAAE8D;YAAU,CAAC;UAAE,CAAC,CAAC;UAC7LqG,aAAa,GAAGrG,SAAS;QAC7B;QACA,OAAOsG,gBAAgB;MAC3B;MACA,OAAOtG,SAAS;IACpB,CAAC;IACD,MAAM0H,aAAa,GAAG,SAAAA,CAACC,QAAQ,EAAc;MAAA,SAAAC,KAAA,GAAA5B,SAAA,CAAArK,MAAA,EAATkM,IAAI,OAAA9L,KAAA,CAAA6L,KAAA,OAAAA,KAAA,WAAAE,KAAA,MAAAA,KAAA,GAAAF,KAAA,EAAAE,KAAA;QAAJD,IAAI,CAAAC,KAAA,QAAA9B,SAAA,CAAA8B,KAAA;MAAA;MACpC,MAAMC,UAAU,GAAG7B,QAAQ,CAACjG,MAAM,CAAC0H,QAAQ,EAAE,GAAGE,IAAI,CAAC;MACrD,MAAMG,aAAa,GAAG,CAAC,EAAED,UAAU,IAAIA,UAAU,CAAC7L,IAAI,CAAC;MACvD,IAAI8L,aAAa,EAAE;QACf,MAAMC,QAAQ,GAAGvL,8BAA8B,CAACqL,UAAU,EAAE;UAAEnL;QAAiB,CAAC,CAAC;QACjF,MAAMsL,gBAAgB,GAAGD,QAAQ,CAAC/L,IAAI,KAAK6L,UAAU,CAAC7L,IAAI;QAC1D,IAAIgM,gBAAgB,EAAE;UAClB,OAAOhC,QAAQ,CAACjG,MAAM,CAAC;YAAE,GAAG0H,QAAQ;YAAEzL,IAAI,EAAE+L,QAAQ,CAAC/L;UAAK,CAAC,EAAE,GAAG2L,IAAI,CAAC;QACzE;MACJ;MACA,OAAOE,UAAU;IACrB,CAAC;IACD,OAAO;MACH9H,MAAMA,CAACnE,EAAE,EAAEqM,eAAe,EAAuC;QAAA,IAArC;UAAEC,cAAc,GAAG,IAAIC,GAAG,CAAC;QAAE,CAAC,GAAArC,SAAA,CAAArK,MAAA,QAAAqK,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,CAAC,CAAC;QAC3DI,UAAU,GAAGtK,EAAE;QACf,IAAI,OAAOA,EAAE,CAACI,IAAI,KAAK,QAAQ,EAAE;UAC7BiK,KAAK,GAAG,IAAI;QAChB,CAAC,MACI,IAAI,CAAC,CAAC,EAAE5L,UAAU,CAAC+N,iBAAiB,EAAExM,EAAE,CAAC,EAAE;UAC5CsM,cAAc,CAACG,GAAG,CAACzM,EAAE,CAACI,IAAI,EAAEJ,EAAE,CAACiB,KAAK,CAAChD,KAAK,CAAC;UAC3C,MAAMyO,YAAY,GAAG5O,MAAM,CAACyN,MAAM,CAAEtK,KAAK,IAAKA,KAAK,CAACD,QAAQ,EAAEhB,EAAE,CAACI,IAAI,CAAC;UACtE,OAAO,CAAC,CAAC,EAAEvB,sBAAsB,CAAC8N,mBAAmB,EAAE,MAAMf,aAAa,CAAC;YAAE,GAAG5L,EAAE;YAAEI,IAAI,EAAEsM;UAAa,CAAC,CAAC,CAAC;QAC9G,CAAC,MACI,IAAI,CAAC,CAAC,EAAEjO,UAAU,CAACmO,iBAAiB,EAAE5M,EAAE,CAAC,EAAE;UAC5C,MAAM2E,QAAQ,GAAGwC,OAAO,CAAC0F,uBAAuB,CAAC7M,EAAE,CAACI,IAAI,CAAC;UACzD,MAAMnC,KAAK,GAAGqO,cAAc,CAACQ,GAAG,CAACnI,QAAQ,CAAC,GACpC2H,cAAc,CAACS,GAAG,CAACpI,QAAQ,CAAC,GAC5BD,uBAAuB,CAACC,QAAQ,CAAC;UACvC,MAAMqI,YAAY,GAAGlP,MAAM,CAACyN,MAAM,CAAEtK,KAAK,IAAKA,KAAK,CAACD,QAAQ,CAAC/C,KAAK,CAAC,EAAE+B,EAAE,CAACI,IAAI,CAAC;UAC7E,OAAO,CAAC,CAAC,EAAEvB,sBAAsB,CAAC8N,mBAAmB,EAAE,MAAMf,aAAa,CAAC;YAAE,GAAG5L,EAAE;YAAEI,IAAI,EAAE4M;UAAa,CAAC,CAAC,CAAC;QAC9G,CAAC,MACI;UACD3C,KAAK,GAAG,KAAK;UACb,IAAI4B,UAAU,GAAGjM,EAAE;UACnB,IAAIS,MAAM,CAACwL,UAAU,CAAC,EAAE;YACpB,MAAMtF,SAAS,CAAC,qDAAqD,CAAC;UAC1E;UACAsF,UAAU,GAAGrL,8BAA8B,CAACqL,UAAU,EAAE;YAAEnL;UAAiB,CAAC,CAAC;UAC7E,MAAM;YAAEV,IAAI,EAAE8D;UAAU,CAAC,GAAG+H,UAAU;UACtC,MAAM5E,OAAO,GAAG,CAAC,CAAC,EAAExI,sBAAsB,CAACoO,gBAAgB,EAAE/I,SAAS,CAACgJ,YAAY,EAAEb,eAAe,CAAC;UACrG,IAAI/L,MAAM,CAACN,EAAE,CAACI,IAAI,CAAC,EAAE;YACjB,MAAM;cAAEA,IAAI,EAAE+M,SAAS;cAAExC;YAAQ,CAAC,GAAG3K,EAAE,CAACI,IAAI;YAC5C,OAAO,CAAC,CAAC,EAAEvB,sBAAsB,CAAC8N,mBAAmB,EAAE,MAAMf,aAAa,CAAC;cAAE,GAAG5L,EAAE;cAAEI,IAAI,EAAEsK,iBAAiB,CAACyC,SAAS,EAAExC,OAAO;YAAE,CAAC,EAAEtD,OAAO,CAAC,CAAC;UAChJ;UACA,MAAM+F,mBAAmB,GAAGlI,UAAU,CAAChB,SAAS,CAAC;UACjD,IAAI,CAACkJ,mBAAmB,IAAI,OAAOlJ,SAAS,KAAK,UAAU,EAAE;YACzD,OAAO,CAAC,CAAC,EAAErF,sBAAsB,CAAC8N,mBAAmB,EAAE,MAAMf,aAAa,CAAC;cAAE,GAAGK,UAAU;cAAE7L,IAAI,EAAEqL,uBAAuB,CAACvH,SAAS;YAAE,CAAC,EAAEmD,OAAO,CAAC,CAAC;UACrJ;UACA,IAAI+F,mBAAmB,EAAE;YACrB,IAAIhD,QAAQ,CAAC/F,SAAS,IAClBrE,EAAE,CAACiB,KAAK,KAAKmJ,QAAQ,CAAC/F,SAAS,CAACpD,KAAK,IACrC,CAAC,CAAC,CAAC,EAAErC,sBAAsB,CAACK,OAAO,EAAEoI,OAAO,EAAE+C,QAAQ,CAAC/F,SAAS,CAACgD,OAAO,CAAC,EAAE;cAC3E,MAAM;gBAAEgG;cAAQ,CAAC,GAAG,CAAC,CAAC,EAAExO,sBAAsB,CAACyO,SAAS,EAAElD,QAAQ,EAAE,uBAAuB,EAAGmD,cAAc,IAAK,SAASC,qBAAqBA,CAAA,EAAU;gBACrJ,MAAM;kBAAEvM;gBAAM,CAAC,GAAGmJ,QAAQ,CAAC/F,SAAS;gBACpC,MAAMoJ,WAAW,GAAG;kBAAE,GAAGxM;gBAAM,CAAC;gBAChCmJ,QAAQ,CAAC/F,SAAS,CAACpD,KAAK,GAAGwM,WAAW;gBAAC,SAAAC,KAAA,GAAAxD,SAAA,CAAArK,MAAA,EAHwGuL,IAAI,OAAAnL,KAAA,CAAAyN,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;kBAAJvC,IAAI,CAAAuC,KAAA,IAAAzD,SAAA,CAAAyD,KAAA;gBAAA;gBAInJ,MAAMjO,MAAM,GAAG6N,cAAc,CAACK,KAAK,CAACxD,QAAQ,EAAEgB,IAAI,CAAC;gBACnDhB,QAAQ,CAAC/F,SAAS,CAACpD,KAAK,GAAGA,KAAK;gBAChCoM,OAAO,CAAC,CAAC;gBACT,OAAO3N,MAAM;cACjB,CAAC,CAAC;YACN;YACA;YACA,MAAMmO,eAAe,GAAG7J,kBAAkB,CAAC,CAAC;YAC5C,IAAI6J,eAAe,EAAE;cACjB/P,MAAM,CAACC,cAAc,CAACmG,SAAS,CAACiB,SAAS,EAAE,OAAO,EAAE;gBAChD2I,YAAY,EAAE,IAAI;gBAClBC,UAAU,EAAE,IAAI;gBAChBhB,GAAGA,CAAA,EAAG;kBACF,OAAO,IAAI;gBACf,CAAC;gBACDN,GAAGA,CAACxO,KAAK,EAAE;kBACP,IAAIA,KAAK,KAAK4P,eAAe,EAAE;oBAC3B/P,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,OAAO,EAAE;sBACjC+P,YAAY,EAAE,IAAI;sBAClBC,UAAU,EAAE,IAAI;sBAChB9P,KAAK;sBACL+P,QAAQ,EAAE;oBACd,CAAC,CAAC;kBACN;gBACJ;cACJ,CAAC,CAAC;YACN;UACJ;UACA,OAAO,CAAC,CAAC,EAAEnP,sBAAsB,CAAC8N,mBAAmB,EAAE,MAAMf,aAAa,CAACK,UAAU,EAAE5E,OAAO,CAAC,CAAC;QACpG;MACJ,CAAC;MACDY,OAAOA,CAAA,EAAG;QACNmC,QAAQ,CAACnC,OAAO,CAAC,CAAC;MACtB,CAAC;MACDC,OAAOA,CAAA,EAAG;QACN,IAAImC,KAAK,EAAE;UACP,OAAO/I,aAAa,CAACgJ,UAAU,CAAC;QACpC;QACA,MAAM2D,MAAM,GAAG7D,QAAQ,CAAC8D,eAAe,CAAC,CAAC;QACzC,OAAO;UACHzM,QAAQ,EAAEtB,gBAAgB,CAACmK,UAAU,CAAClK,IAAI,CAAC;UAC3CA,IAAI,EAAEkK,UAAU,CAAClK,IAAI;UACrBa,KAAK,EAAEqJ,UAAU,CAACrJ,KAAK;UACvBS,GAAG,EAAE,CAAC,CAAC,EAAE7C,sBAAsB,CAAC8C,oBAAoB,EAAE2I,UAAU,CAAC5I,GAAG,CAAC;UACrEE,GAAG,EAAE0I,UAAU,CAAC1I,GAAG;UACnBC,QAAQ,EAAEuI,QAAQ,CAAC/F,SAAS;UAC5BvC,QAAQ,EAAE7B,KAAK,CAACC,OAAO,CAAC+N,MAAM,CAAC,GACzBzO,OAAO,CAACyO,MAAM,CAAC,CAACnL,GAAG,CAAE9C,EAAE,IAAKsB,aAAa,CAACtB,EAAE,CAAC,CAAC,GAC9CsB,aAAa,CAAC2M,MAAM;QAC9B,CAAC;MACL,CAAC;MACD1F,aAAaA,CAACC,aAAa,EAAEtB,QAAQ,EAAEuB,KAAK,EAAE;QAC1C,CAAC,CAAC,EAAE5J,sBAAsB,CAAC0J,aAAa,EAAEE,KAAK,EAAE2B,QAAQ,CAAC/F,SAAS,EAAEiG,UAAU,EAAE9B,aAAa,CAAC2F,MAAM,CAAC7D,UAAU,CAAC,EAAEnK,gBAAgB,EAAEgH,OAAO,CAAC8B,iBAAiB,EAAEqB,UAAU,CAAClK,IAAI,CAAC;MACpL,CAAC;MACD8I,aAAaA,CAAC7J,IAAI,EAAE8J,KAAK,EAAW;QAAA,SAAAiF,KAAA,GAAAlE,SAAA,CAAArK,MAAA,EAANuL,IAAI,OAAAnL,KAAA,CAAAmO,KAAA,OAAAA,KAAA,WAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;UAAJjD,IAAI,CAAAiD,KAAA,QAAAnE,SAAA,CAAAmE,KAAA;QAAA;QAC9B,MAAMC,OAAO,GAAGjP,IAAI,CAAC4B,KAAK,CAAC,CAAC,CAAC,EAAEpC,sBAAsB,CAAC0P,aAAa,EAAEpF,KAAK,CAAC,CAAC;QAC5E,IAAImF,OAAO,EAAE;UACT,CAAC,CAAC,EAAEzP,sBAAsB,CAAC8N,mBAAmB,EAAE,MAAM;YAClD;YACA;YACA;YACA2B,OAAO,CAAC,GAAGlD,IAAI,CAAC;YAChB;UACJ,CAAC,CAAC;QACN;MACJ,CAAC;MACD1B,cAAcA,CAAC8E,EAAE,EAAE;QACf,OAAOA,EAAE,CAAC,CAAC;QACX;MACJ,CAAC;MACD;MACA;MACA;MACA;MACAC,cAAcA,CAACC,SAAS,EAAEC,MAAM,EAAEC,QAAQ,EAAEC,SAAS,EAAE;QACnD,OAAO,IAAI;MACf;IACJ,CAAC;EACL;EACAC,oBAAoBA,CAACpJ,OAAO,EAAE;IAC1B,IAAI,CAAC,CAAC,EAAElH,KAAK,CAACS,OAAO,EAAEyG,OAAO,EAAE,kBAAkB,CAAC,EAAE;MACjD,MAAM,IAAIiB,SAAS,CAAC,0EAA0E,CAAC;IACnG;IACA;IACA;IACA,IAAI,CAACH,UAAU,CAACuI,WAAW,EAAE;MACzB,MAAM,IAAIrL,KAAK,CAAC;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,CAAC;IACA;IACA,MAAMsL,cAAc,GAAG7Q,OAAO,CAAC,kBAAkB,CAAC;IAClD,OAAO;MACHgG,MAAMA,CAACnE,EAAE,EAAEqH,OAAO,EAAE;QAChB,IAAI3B,OAAO,CAAC2B,OAAO,KAAKrH,EAAE,CAACI,IAAI,CAAC8M,YAAY,IAAIxH,OAAO,CAACuJ,iBAAiB,CAAC,EAAE;UACxE,MAAMA,iBAAiB,GAAG;YACtB,IAAIjP,EAAE,CAACI,IAAI,CAAC8M,YAAY,IAAI,CAAC,CAAC,CAAC;YAC/B,GAAGxH,OAAO,CAACuJ;UACf,CAAC;UACD,MAAMC,cAAc,GAAG,CAAC,CAAC,EAAErQ,sBAAsB,CAACsQ,mBAAmB,EAAEnP,EAAE,EAAEqH,OAAO,EAAE4H,iBAAiB,CAAC;UACtG,OAAOD,cAAc,CAACI,oBAAoB,CAAClR,OAAO,CAACe,OAAO,CAACoC,aAAa,CAAC6N,cAAc,CAAC,CAAC;QAC7F;QACA,OAAOF,cAAc,CAACI,oBAAoB,CAACpP,EAAE,CAAC;MAClD;IACJ,CAAC;EACL;EACA;EACA;EACAqP,cAAcA,CAAC3J,OAAO,EAAE;IACpB,QAAQA,OAAO,CAAC4J,IAAI;MAChB;MACA,KAAK5Q,QAAQ,CAAC6G,aAAa,CAACgK,KAAK,CAACC,KAAK;QAAE;QACrC,OAAO,IAAI,CAACjJ,mBAAmB,CAACb,OAAO,CAAC;MAC5C;MACA,KAAKhH,QAAQ,CAAC6G,aAAa,CAACgK,KAAK,CAACE,OAAO;QAAE;QACvC,OAAO,IAAI,CAACxF,qBAAqB,CAACvE,OAAO,CAAC;MAC9C;MACA,KAAKhH,QAAQ,CAAC6G,aAAa,CAACgK,KAAK,CAACG,MAAM;QAAE;QACtC,OAAO,IAAI,CAACZ,oBAAoB,CAACpJ,OAAO,CAAC;MAC7C;QACI,MAAM,IAAIhC,KAAK,CAAC,6CAA6CgC,OAAO,CAAC4J,IAAI,EAAE,CAAC;IACpF;EACJ;EACAhH,IAAIA,CAACqH,OAAO,EAAE;IACV,OAAO,CAAC,CAAC,EAAE9Q,sBAAsB,CAACyJ,IAAI,EAAEqH,OAAO,CAAC;EACpD;EACA;EACA;EACA;EACAC,aAAaA,CAACvQ,IAAI,EAAE;IAChB,IAAI,CAACA,IAAI,IAAI,OAAOA,IAAI,KAAK,QAAQ,EACjC,OAAO,IAAI;IACf,MAAM;MAAEe;IAAK,CAAC,GAAGf,IAAI;IACrB,OAAOnB,OAAO,CAACe,OAAO,CAACoC,aAAa,CAACV,UAAU,CAACP,IAAI,CAAC,EAAE,CAAC,CAAC,EAAEvB,sBAAsB,CAACgR,mBAAmB,EAAExQ,IAAI,CAAC,CAAC;EACjH;EACAyQ,kBAAkBA,CAACzQ,IAAI,EAAE0Q,YAAY,EAAE;IACnC,IAAI,CAAC1Q,IAAI,EAAE;MACP,OAAOA,IAAI;IACf;IACA,MAAM;MAAEe;IAAK,CAAC,GAAGf,IAAI;IACrB,OAAOsB,UAAU,CAACP,IAAI,CAAC,KAAKO,UAAU,CAACoP,YAAY,CAAC;EACxD;EACAC,aAAaA,CAACL,OAAO,EAAE;IACnB,OAAOrO,aAAa,CAACqO,OAAO,CAAC;EACjC;EACAhM,cAAcA,CAACtE,IAAI,EAAyB;IAAA,IAAvB4Q,aAAa,GAAA/F,SAAA,CAAArK,MAAA,QAAAqK,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,KAAK;IACtC,MAAMgG,KAAK,GAAGvM,cAAc,CAACtE,IAAI,CAAC;IAClC,IAAIY,KAAK,CAACC,OAAO,CAACgQ,KAAK,CAAC,IAAI,CAACD,aAAa,EAAE;MACxC;MACA,OAAOC,KAAK,CAACC,MAAM,CAACC,OAAO,CAAC,CAAC,CAAC,CAAC;IACnC;IACA,OAAOF,KAAK;EAChB;EACAjH,iBAAiBA,CAAC5J,IAAI,EAAE;IACpB,IAAI,CAACA,IAAI,EACL,OAAO,IAAI;IACf,MAAM;MAAEe,IAAI;MAAE4E;IAAS,CAAC,GAAG3F,IAAI;IAC/B,MAAM8H,OAAO,GAAG,IAAI;IACpB,MAAM1F,QAAQ,GAAGrB,IAAI,IAAI4E,QAAQ;IACjC;IACA,IAAIvD,QAAQ,EAAE;MACV,QAAQA,QAAQ;QACZ,KAAKhD,UAAU,CAAC4R,cAAc,IAAIC,GAAG;UACjC,OAAO,gBAAgB;QAC3B,KAAK7R,UAAU,CAACwE,QAAQ,IAAIqN,GAAG;UAC3B,OAAO,UAAU;QACrB,KAAK7R,UAAU,CAAC8R,UAAU,IAAID,GAAG;UAC7B,OAAO,YAAY;QACvB,KAAK7R,UAAU,CAAC4E,QAAQ,IAAIiN,GAAG;UAC3B,OAAO,UAAU;QACrB,KAAK7R,UAAU,CAAC4B,MAAM,IAAIiQ,GAAG;UACzB,OAAO,QAAQ;QACnB,KAAK7R,UAAU,CAAC+E,QAAQ,IAAI8M,GAAG;UAC3B,OAAO,UAAU;QACrB;MACJ;IACJ;IACA,MAAME,YAAY,GAAGpQ,IAAI,IAAIA,IAAI,CAAC4E,QAAQ;IAC1C,QAAQwL,YAAY;MAChB,KAAK/R,UAAU,CAAC2E,eAAe,IAAIkN,GAAG;QAClC,OAAO,iBAAiB;MAC5B,KAAK7R,UAAU,CAAC0E,eAAe,IAAImN,GAAG;QAClC,OAAO,iBAAiB;MAC5B,KAAK7R,UAAU,CAAC+B,IAAI,IAAI8P,GAAG;QAAE;UACzB,MAAMG,QAAQ,GAAG,CAAC,CAAC,EAAE5R,sBAAsB,CAACoK,iBAAiB,EAAE5J,IAAI,CAAC;UACpE,OAAO,OAAOoR,QAAQ,KAAK,QAAQ,GAAGA,QAAQ,GAAG,QAAQtJ,OAAO,CAAC8B,iBAAiB,CAAC7I,IAAI,CAAC,GAAG;QAC/F;MACA,KAAK3B,UAAU,CAAC6E,UAAU,IAAIgN,GAAG;QAAE;UAC/B,IAAIlQ,IAAI,CAACoL,WAAW,EAAE;YAClB,OAAOpL,IAAI,CAACoL,WAAW;UAC3B;UACA,MAAMkF,IAAI,GAAGvJ,OAAO,CAAC8B,iBAAiB,CAAC;YAAE7I,IAAI,EAAEA,IAAI,CAAC+D;UAAO,CAAC,CAAC;UAC7D,OAAOuM,IAAI,GAAG,cAAcA,IAAI,GAAG,GAAG,YAAY;QACtD;MACA,KAAKjS,UAAU,CAACiC,IAAI,IAAI4P,GAAG;QAAE;UACzB,OAAO,MAAM;QACjB;MACA;QACI,OAAO,CAAC,CAAC,EAAEzR,sBAAsB,CAACoK,iBAAiB,EAAE5J,IAAI,CAAC;IAClE;EACJ;EACAsR,cAAcA,CAAChB,OAAO,EAAE;IACpB,OAAO,CAAC,CAAC,EAAElR,UAAU,CAACmS,SAAS,EAAEjB,OAAO,CAAC;EAC7C;EACAkB,kBAAkBA,CAACC,MAAM,EAAE;IACvB,OAAO,CAAC,CAACA,MAAM,IAAI,CAAC,CAAC,EAAErS,UAAU,CAACoS,kBAAkB,EAAEC,MAAM,CAAC;EACjE;EACAC,UAAUA,CAACC,QAAQ,EAAE;IACjB,OAAO,CAAC,CAAC,EAAErS,OAAO,CAACsS,UAAU,EAAED,QAAQ,CAAC,KAAKvS,UAAU,CAACwE,QAAQ;EACpE;EACAmF,iBAAiBA,CAAChI,IAAI,EAAE;IACpB,MAAM8Q,WAAW,GAAGnM,eAAe,CAAC3E,IAAI,CAAC;IACzC,OAAQ,CAAC,CAACA,IAAI,KACT,OAAOA,IAAI,KAAK,UAAU,IACvB,CAAC,CAAC,EAAE3B,UAAU,CAAC0S,YAAY,EAAED,WAAW,CAAC,IACzC,CAAC,CAAC,EAAEzS,UAAU,CAAC+N,iBAAiB,EAAE0E,WAAW,CAAC,IAC9C,CAAC,CAAC,EAAEzS,UAAU,CAACmO,iBAAiB,EAAEsE,WAAW,CAAC,IAC9C,CAAC,CAAC,EAAEzS,UAAU,CAACsC,UAAU,EAAEmQ,WAAW,CAAC,CAAC;EACpD;EACAtE,iBAAiBA,CAACxM,IAAI,EAAE;IACpB,OAAO,CAAC,CAACA,IAAI,IAAI,CAAC,CAAC,EAAE3B,UAAU,CAACmO,iBAAiB,EAAE7H,eAAe,CAAC3E,IAAI,CAAC,CAAC;EAC7E;EACAgR,wBAAwBA,CAACtH,IAAI,EAAE;IAC3B,IAAI,CAACA,IAAI,IAAI,CAAC,IAAI,CAAC6G,cAAc,CAAC7G,IAAI,CAAC,EAAE;MACrC,OAAO,KAAK;IAChB;IACA,OAAO,IAAI,CAAC1B,iBAAiB,CAAC0B,IAAI,CAAC1J,IAAI,CAAC;EAC5C;EACAyM,uBAAuBA,CAACwE,QAAQ,EAAE;IAC9B;IACA,IAAIA,QAAQ,EAAE;MACV,IAAI1M,QAAQ;MACZ,IAAI0M,QAAQ,CAACzM,QAAQ,EAAE;QACnB;QACA,CAAC;UAAED;QAAS,CAAC,GAAG0M,QAAQ,CAACzM,QAAQ;MACrC,CAAC,MACI,IAAIyM,QAAQ,CAAC1M,QAAQ,EAAE;QACxB,CAAC;UAAEA;QAAS,CAAC,GAAG0M,QAAQ;MAC5B;MACA,IAAI1M,QAAQ,EAAE;QACV,OAAOA,QAAQ;MACnB;IACJ;IACA,MAAM,IAAIjB,KAAK,CAAC,2EAA2E,CAAC;EAChG;EACArC,aAAaA,CAAA,EAAU;IACnB;IACA,OAAOnD,OAAO,CAACe,OAAO,CAACoC,aAAa,CAAC,GAAA6I,SAAO,CAAC;EACjD;EACA;EACAoH,yBAAyBA,CAACjS,IAAI,EAAEqG,OAAO,EAAE;IACrC,OAAO;MACH6L,UAAU,EAAE1S,sBAAsB,CAAC0S,UAAU;MAC7ClS,IAAI,EAAE,CAAC,CAAC,EAAER,sBAAsB,CAACyS,yBAAyB,EAAEpT,OAAO,CAACe,OAAO,CAACoC,aAAa,EAAEhC,IAAI,EAAEqG,OAAO;IAC5G,CAAC;EACL;AACJ;AACA1H,OAAO,CAACiB,OAAO,GAAGqG,oBAAoB","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}